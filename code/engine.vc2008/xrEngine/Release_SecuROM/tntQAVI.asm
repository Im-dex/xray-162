; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\tntQAVI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_GCAviPlayerCustom@@QAEPAXI@Z			; CAviPlayerCustom::`scalar deleting destructor'
PUBLIC	??R?$xr_special_free@$0A@VCAviPlayerCustom@@@@QAEXAAPAVCAviPlayerCustom@@@Z ; xr_special_free<0,CAviPlayerCustom>::operator()
PUBLIC	??$xr_delete@VCAviPlayerCustom@@@@YAXAAPAVCAviPlayerCustom@@@Z ; xr_delete<CAviPlayerCustom>
PUBLIC	?xr_malloc@@YAPAXI@Z				; xr_malloc
PUBLIC	??$xr_free@E@@YAXAAPAE@Z			; xr_free<unsigned char>
PUBLIC	??$xr_free@UAVIINDEXENTRY@@@@YAXAAPAUAVIINDEXENTRY@@@Z ; xr_free<AVIINDEXENTRY>
PUBLIC	??$xr_new@VCAviPlayerCustom@@@@YAPAVCAviPlayerCustom@@XZ ; xr_new<CAviPlayerCustom>
PUBLIC	??_C@_06HJHJJPIO@_alpha?$AA@			; `string'
PUBLIC	??_C@_0BH@PAAIHHNJ@CAviPlayerCustom?3?3Load?$AA@ ; `string'
PUBLIC	??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@ ; `string'
PUBLIC	??_C@_0BI@HBNFHHDI@m_dwWidth?5?$CG?$CG?5m_dwHeight?$AA@ ; `string'
PUBLIC	??_C@_0BO@KLKFEPLC@m_dwWidth?5?$DN?$DN?5alpha?9?$DOm_dwWidth?$AA@ ; `string'
PUBLIC	??_C@_0CA@LPKIBLFL@m_dwHeight?5?$DN?$DN?5alpha?9?$DOm_dwHeight?$AA@ ; `string'
PUBLIC	??_C@_0CC@OEELJIGN@CAviPlayerCustom?3?3DecompressFram@ ; `string'
PUBLIC	??_C@_0BO@OILNMJHF@m_biInFormat?4biSizeImage?5?$CB?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_0BL@ELJMIBML@CAviPlayerCustom?3?3GetFrame?$AA@ ; `string'
PUBLIC	??_C@_05PJHAMANO@pDest?$AA@			; `string'
PUBLIC	??_C@_0BK@JPNAEOKM@CAviPlayerCustom?3?3PreRoll?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JNJHNBDE@m_biInFormat?4biSizeImage?$AA@ ; `string'
EXTRN	_ICClose@4:PROC
EXTRN	__imp__mmioOpenA@12:PROC
EXTRN	__imp__mmioClose@8:PROC
EXTRN	__imp__mmioRead@12:PROC
EXTRN	__imp__mmioSeek@12:PROC
EXTRN	__imp__mmioDescend@16:PROC
EXTRN	__imp__mmioAscend@12:PROC
EXTRN	_ICSendMessage@16:PROC
EXTRN	_ICLocate@20:PROC
EXTRN	_AVIFileInit@0:PROC
EXTRN	_AVIFileRelease@4:PROC
EXTRN	_AVIFileOpenA@16:PROC
EXTRN	_AVIFileInfoA@12:PROC
EXTRN	_ICDecompress:PROC
;	COMDAT ?ignore_always@?BO@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BO@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA DB 01H DUP (?) ; `CAviPlayerCustom::Load'::`30'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?EP@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?EP@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA DB 01H DUP (?) ; `CAviPlayerCustom::Load'::`79'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?FD@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?FD@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA DB 01H DUP (?) ; `CAviPlayerCustom::Load'::`83'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??DecompressFrame@CAviPlayerCustom@@IAEHK@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??DecompressFrame@CAviPlayerCustom@@IAEHK@Z@4_NA DB 01H DUP (?) ; `CAviPlayerCustom::DecompressFrame'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??GetFrame@CAviPlayerCustom@@QAEHPAPAE@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??GetFrame@CAviPlayerCustom@@QAEHPAPAE@Z@4_NA DB 01H DUP (?) ; `CAviPlayerCustom::GetFrame'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BA@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BA@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA DB 01H DUP (?) ; `CAviPlayerCustom::PreRoll'::`16'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BE@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BE@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA DB 01H DUP (?) ; `CAviPlayerCustom::PreRoll'::`20'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BL@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BL@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA DB 01H DUP (?) ; `CAviPlayerCustom::PreRoll'::`27'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?CE@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA
_BSS	SEGMENT
?ignore_always@?CE@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA DB 01H DUP (?) ; `CAviPlayerCustom::PreRoll'::`36'::ignore_always
;	COMDAT ??_C@_0BJ@JNJHNBDE@m_biInFormat?4biSizeImage?$AA@
CONST	SEGMENT
??_C@_0BJ@JNJHNBDE@m_biInFormat?4biSizeImage?$AA@ DB 'm_biInFormat.biSize'
	DB	'Image', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JPNAEOKM@CAviPlayerCustom?3?3PreRoll?$AA@
CONST	SEGMENT
??_C@_0BK@JPNAEOKM@CAviPlayerCustom?3?3PreRoll?$AA@ DB 'CAviPlayerCustom:'
	DB	':PreRoll', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05PJHAMANO@pDest?$AA@
CONST	SEGMENT
??_C@_05PJHAMANO@pDest?$AA@ DB 'pDest', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ELJMIBML@CAviPlayerCustom?3?3GetFrame?$AA@
CONST	SEGMENT
??_C@_0BL@ELJMIBML@CAviPlayerCustom?3?3GetFrame?$AA@ DB 'CAviPlayerCustom'
	DB	'::GetFrame', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OILNMJHF@m_biInFormat?4biSizeImage?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BO@OILNMJHF@m_biInFormat?4biSizeImage?5?$CB?$DN?50?$AA@ DB 'm_biIn'
	DB	'Format.biSizeImage != 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OEELJIGN@CAviPlayerCustom?3?3DecompressFram@
CONST	SEGMENT
??_C@_0CC@OEELJIGN@CAviPlayerCustom?3?3DecompressFram@ DB 'CAviPlayerCust'
	DB	'om::DecompressFrame', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LPKIBLFL@m_dwHeight?5?$DN?$DN?5alpha?9?$DOm_dwHeight?$AA@
CONST	SEGMENT
??_C@_0CA@LPKIBLFL@m_dwHeight?5?$DN?$DN?5alpha?9?$DOm_dwHeight?$AA@ DB 'm'
	DB	'_dwHeight == alpha->m_dwHeight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KLKFEPLC@m_dwWidth?5?$DN?$DN?5alpha?9?$DOm_dwWidth?$AA@
CONST	SEGMENT
??_C@_0BO@KLKFEPLC@m_dwWidth?5?$DN?$DN?5alpha?9?$DOm_dwWidth?$AA@ DB 'm_d'
	DB	'wWidth == alpha->m_dwWidth', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HBNFHHDI@m_dwWidth?5?$CG?$CG?5m_dwHeight?$AA@
CONST	SEGMENT
??_C@_0BI@HBNFHHDI@m_dwWidth?5?$CG?$CG?5m_dwHeight?$AA@ DB 'm_dwWidth && '
	DB	'm_dwHeight', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
CONST	SEGMENT
??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@ DB 'D:\CLEARSKY'
	DB	'\sources\engine\xrEngine\tntQAVI.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PAAIHHNJ@CAviPlayerCustom?3?3Load?$AA@
CONST	SEGMENT
??_C@_0BH@PAAIHHNJ@CAviPlayerCustom?3?3Load?$AA@ DB 'CAviPlayerCustom::Lo'
	DB	'ad', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06HJHJJPIO@_alpha?$AA@
CONST	SEGMENT
??_C@_06HJHJJPIO@_alpha?$AA@ DB '_alpha', 00H		; `string'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
;	COMDAT ??$xr_free@E@@YAXAAPAE@Z
_TEXT	SEGMENT
??$xr_free@E@@YAXAAPAE@Z PROC				; xr_free<unsigned char>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@21
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@21:
	ret	0
??$xr_free@E@@YAXAAPAE@Z ENDP				; xr_free<unsigned char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?xr_malloc@@YAPAXI@Z
_TEXT	SEGMENT
?xr_malloc@@YAPAXI@Z PROC				; xr_malloc, COMDAT
; _size$ = eax

; 112  : 	IC void*	xr_malloc	(size_t size)			{	return	Memory.mem_alloc(size);					}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?xr_malloc@@YAPAXI@Z ENDP				; xr_malloc
_TEXT	ENDS
PUBLIC	??1CAviPlayerCustom@@QAE@XZ			; CAviPlayerCustom::~CAviPlayerCustom
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VCAviPlayerCustom@@@@QAEXAAPAVCAviPlayerCustom@@@Z
_TEXT	SEGMENT
??R?$xr_special_free@$0A@VCAviPlayerCustom@@@@QAEXAAPAVCAviPlayerCustom@@@Z PROC ; xr_special_free<0,CAviPlayerCustom>::operator(), COMDAT
; _ptr$ = esi

; 143  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	call	??1CAviPlayerCustom@@QAE@XZ		; CAviPlayerCustom::~CAviPlayerCustom

; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 145  : 	}

	ret	0
??R?$xr_special_free@$0A@VCAviPlayerCustom@@@@QAEXAAPAVCAviPlayerCustom@@@Z ENDP ; xr_special_free<0,CAviPlayerCustom>::operator()
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_delete@VCAviPlayerCustom@@@@YAXAAPAVCAviPlayerCustom@@@Z
_TEXT	SEGMENT
??$xr_delete@VCAviPlayerCustom@@@@YAXAAPAVCAviPlayerCustom@@@Z PROC ; xr_delete<CAviPlayerCustom>, COMDAT
; _ptr$ = esi

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1@xr_delete@4

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);

	call	??1CAviPlayerCustom@@QAE@XZ		; CAviPlayerCustom::~CAviPlayerCustom
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = NULL;

	mov	DWORD PTR [esi], 0
$LN1@xr_delete@4:

; 155  : 	}
; 156  : }

	ret	0
??$xr_delete@VCAviPlayerCustom@@@@YAXAAPAVCAviPlayerCustom@@@Z ENDP ; xr_delete<CAviPlayerCustom>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
_TEXT	ENDS
;	COMDAT ??$xr_free@UAVIINDEXENTRY@@@@YAXAAPAUAVIINDEXENTRY@@@Z
_TEXT	SEGMENT
??$xr_free@UAVIINDEXENTRY@@@@YAXAAPAUAVIINDEXENTRY@@@Z PROC ; xr_free<AVIINDEXENTRY>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@22
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@22:
	ret	0
??$xr_free@UAVIINDEXENTRY@@@@YAXAAPAUAVIINDEXENTRY@@@Z ENDP ; xr_free<AVIINDEXENTRY>
_TEXT	ENDS
PUBLIC	__real@3c23d70a
PUBLIC	__real@42c80000
PUBLIC	?SetSpeed@CAviPlayerCustom@@QAEHH@Z		; CAviPlayerCustom::SetSpeed
;	COMDAT __real@3c23d70a
; File d:\clearsky\sources\engine\xrengine\tntqavi.cpp
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?SetSpeed@CAviPlayerCustom@@QAEHH@Z
_TEXT	SEGMENT
_nPercent$ = 8						; size = 4
?SetSpeed@CAviPlayerCustom@@QAEHH@Z PROC		; CAviPlayerCustom::SetSpeed, COMDAT
; _this$ = ecx

; 426  : 	INT		res = INT( m_fCurrentRate / m_fRate * 100 );

	movss	xmm0, DWORD PTR [ecx+100]
	movss	xmm1, DWORD PTR [ecx+104]
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@42c80000
	cvttss2si eax, xmm1

; 427  : 
; 428  : 	m_fCurrentRate	= m_fRate * FLOAT( nPercent / 100.0f );

	cvtsi2ss xmm1, DWORD PTR _nPercent$[esp-4]
	mulss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3c23d70a
	movss	DWORD PTR [ecx+104], xmm1

; 429  : 
; 430  : 	return	res;
; 431  : }

	ret	4
?SetSpeed@CAviPlayerCustom@@QAEHH@Z ENDP		; CAviPlayerCustom::SetSpeed
_TEXT	ENDS
PUBLIC	?GetSize@CAviPlayerCustom@@QAEXPAK0@Z		; CAviPlayerCustom::GetSize
; Function compile flags: /Ogtpy
;	COMDAT ?GetSize@CAviPlayerCustom@@QAEXPAK0@Z
_TEXT	SEGMENT
_dwWidth$ = 8						; size = 4
_dwHeight$ = 12						; size = 4
?GetSize@CAviPlayerCustom@@QAEXPAK0@Z PROC		; CAviPlayerCustom::GetSize, COMDAT
; _this$ = ecx

; 420  : 	if( dwWidth )	*dwWidth = m_dwWidth;

	mov	eax, DWORD PTR _dwWidth$[esp-4]
	test	eax, eax
	je	SHORT $LN2@GetSize
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR [eax], edx
$LN2@GetSize:

; 421  : 	if( dwHeight )	*dwHeight = m_dwHeight;

	mov	eax, DWORD PTR _dwHeight$[esp-4]
	test	eax, eax
	je	SHORT $LN1@GetSize
	mov	ecx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax], ecx
$LN1@GetSize:

; 422  : }

	ret	8
?GetSize@CAviPlayerCustom@@QAEXPAK0@Z ENDP		; CAviPlayerCustom::GetSize
_TEXT	ENDS
PUBLIC	?PreRoll@CAviPlayerCustom@@IAEXK@Z		; CAviPlayerCustom::PreRoll
; Function compile flags: /Ogtpy
;	COMDAT ?PreRoll@CAviPlayerCustom@@IAEXK@Z
_TEXT	SEGMENT
_dwFrameNum$ = 8					; size = 4
?PreRoll@CAviPlayerCustom@@IAEXK@Z PROC			; CAviPlayerCustom::PreRoll, COMDAT
; _this$ = ecx

; 349  : {

	push	ebx
	push	ebp

; 350  : 	int i;
; 351  : 
; 352  : 	AVIINDEXENTRY	*pCurrFrameIndex;
; 353  : 	DWORD		res;
; 354  : 
; 355  : 	// находим в массиве индексов первый предшествующий ему ключевой кадр
; 356  : 	// или берем кадр, корректно расжатый до этого
; 357  : 	for( i=(int)dwFrameNum-1 ; i>0 ; i-- ) {

	mov	ebp, DWORD PTR _dwFrameNum$[esp+4]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1]
	test	edi, edi
	mov	esi, ecx
	jle	SHORT $LN28@PreRoll
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, edi
	shl	eax, 4
	lea	eax, DWORD PTR [eax+ecx+4]
	npad	3
$LL30@PreRoll:

; 358  : 
; 359  : 		if( m_pMovieIndex[ i ].dwFlags & AVIIF_KEYFRAME )	break;

	test	BYTE PTR [eax], 16			; 00000010H
	jne	SHORT $LN28@PreRoll

; 360  : 
; 361  : 		if( (int)m_dwFrameCurrent == i ) {

	cmp	DWORD PTR [esi+112], edi
	je	$LN37@PreRoll
	sub	edi, 1
	sub	eax, 16					; 00000010H
	test	edi, edi
	jg	SHORT $LL30@PreRoll
$LN28@PreRoll:

; 378  : 				}
; 379  : 
; 380  : 			} // for(...
; 381  : 		
; 382  : 			return;
; 383  : 		}	// if( (int)m_dwFrameCurrent == i )...
; 384  : 	}	// for( i=(int)dwFrameNum-1 ; i>0 ; i-- )...
; 385  : 
; 386  : 
; 387  : 	// получаем элемент индекса
; 388  : 	pCurrFrameIndex = &m_pMovieIndex[ i ];

	mov	ebx, edi
	shl	ebx, 4
	add	ebx, DWORD PTR [esi+4]

; 389  : 	m_biInFormat.biSizeImage = pCurrFrameIndex->dwChunkLength;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+80], eax

; 390  : 	R_ASSERT( m_biInFormat.biSizeImage );

	cmp	BYTE PTR ?ignore_always@?BE@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA, 0
	jne	SHORT $LN16@PreRoll
	test	eax, eax
	jne	SHORT $LN16@PreRoll
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BE@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA
	push	OFFSET ??_C@_0BK@JPNAEOKM@CAviPlayerCustom?3?3PreRoll?$AA@
	push	390					; 00000186H
	push	OFFSET ??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0BJ@JNJHNBDE@m_biInFormat?4biSizeImage?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN16@PreRoll:

; 391  : 
; 392  : 	// декомпрессим ключевой кадр с флагом ICDECOMPRESS_PREROLL 
; 393  : 	res = ICDecompress(m_aviIC, ICDECOMPRESS_PREROLL | ICDECOMPRESS_HURRYUP, &m_biInFormat, m_pMovieData + pCurrFrameIndex->dwChunkOffset + 8/*m_pCompressedBuf*/, &m_biOutFormat, m_pDecompressedBuf);

	mov	edx, DWORD PTR [esi+16]
	push	edx
	mov	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [esi+20]
	push	eax
	mov	eax, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [eax+edx+8]
	push	eax
	lea	ecx, DWORD PTR [esi+60]
	push	ecx
	mov	ecx, DWORD PTR [esi+12]
	push	-1610612736				; a0000000H
	push	ecx
	call	_ICDecompress
	add	esp, 24					; 00000018H

; 394  : 	if( ICERR_OK != res && ICERR_DONTDRAW != res ) {

	test	eax, eax
	je	SHORT $LN10@PreRoll
	cmp	eax, 1
	je	SHORT $LN10@PreRoll

; 395  : 
; 396  : 		R_ASSERT( 0 );

	cmp	BYTE PTR ?ignore_always@?BL@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA, 0
	jne	SHORT $LN10@PreRoll
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BL@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA
	push	OFFSET ??_C@_0BK@JPNAEOKM@CAviPlayerCustom?3?3PreRoll?$AA@
	push	396					; 0000018cH
	push	OFFSET ??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN10@PreRoll:

; 397  : 	}
; 398  : 
; 399  : 	// декомпрессим все последующие НЕключевые кадры с флагами PREROLL & NOTKEYFRAME
; 400  : 	for( i++ ; i<(int)dwFrameNum ; i++ ) {

	add	edi, 1
	cmp	edi, ebp
	jge	$LN6@PreRoll
	mov	ebx, edi
	shl	ebx, 4
	sub	ebp, edi
	npad	7
$LL8@PreRoll:
	mov	ecx, DWORD PTR [esi+4]

; 401  : 
; 402  : 		pCurrFrameIndex = &m_pMovieIndex[ i ];
; 403  : 
; 404  : 		DWORD	dwFlags;
; 405  : 		dwFlags = ICDECOMPRESS_PREROLL | ICDECOMPRESS_NOTKEYFRAME | ICDECOMPRESS_HURRYUP;
; 406  : 		m_biInFormat.biSizeImage = pCurrFrameIndex->dwChunkLength;

	mov	eax, DWORD PTR [ecx+ebx+12]

; 407  : 		dwFlags |= (m_biInFormat.biSizeImage) ? 0 : ICDECOMPRESS_NULLFRAME;
; 408  : 
; 409  : 		res = ICDecompress(m_aviIC, dwFlags, &m_biInFormat, (m_pMovieData + pCurrFrameIndex->dwChunkOffset + 8) /*m_pCompressedBuf*/, &m_biOutFormat, m_pDecompressedBuf);

	mov	edx, DWORD PTR [esi+16]
	push	edx
	add	ecx, ebx
	mov	DWORD PTR [esi+80], eax
	mov	ecx, DWORD PTR [ecx+8]
	neg	eax
	lea	edx, DWORD PTR [esi+20]
	push	edx
	mov	edx, DWORD PTR [esi+8]
	sbb	eax, eax
	lea	ecx, DWORD PTR [ecx+edx+8]
	mov	edx, DWORD PTR [esi+12]
	push	ecx
	and	eax, -268435456				; f0000000H
	add	eax, 268435456				; 10000000H
	lea	ecx, DWORD PTR [esi+60]
	push	ecx
	or	eax, -1476395008			; a8000000H
	push	eax
	push	edx
	call	_ICDecompress
	add	esp, 24					; 00000018H

; 410  : 		if( ICERR_OK != res && ICERR_DONTDRAW != res ) {	// проверка на ICERR_DONTDRAW введена из-за indeo 5.11

	test	eax, eax
	je	SHORT $LN2@PreRoll
	cmp	eax, 1
	je	SHORT $LN2@PreRoll

; 411  : 
; 412  : 			R_ASSERT( 0 );

	cmp	BYTE PTR ?ignore_always@?CE@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA, 0
	jne	SHORT $LN2@PreRoll
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?CE@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA
	push	OFFSET ??_C@_0BK@JPNAEOKM@CAviPlayerCustom?3?3PreRoll?$AA@
	push	412					; 0000019cH
	push	OFFSET ??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN2@PreRoll:
	add	ebx, 16					; 00000010H
	sub	ebp, 1
	jne	$LL8@PreRoll
$LN6@PreRoll:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 413  : 		}
; 414  : 	} // for(...
; 415  : 
; 416  : }

	ret	4
$LN37@PreRoll:

; 362  : 
; 363  : 			// нам раньше встретился расжатый перед этим кадр:
; 364  : 			// декомпрессим все последующие НЕключевые кадры с флагами PREROLL & NOTKEYFRAME
; 365  : 			for( i++ ; i<(int)dwFrameNum ; i++ ) {

	add	edi, 1
	cmp	edi, ebp
	jge	SHORT $LN6@PreRoll
	mov	ebx, edi
	shl	ebx, 4
	sub	ebp, edi
	mov	edi, DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LL25@PreRoll:
	mov	ecx, DWORD PTR [esi+4]

; 366  : 
; 367  : 				pCurrFrameIndex = &m_pMovieIndex[ i ];
; 368  : 
; 369  : 				DWORD	dwFlags;
; 370  : 				dwFlags = ICDECOMPRESS_PREROLL | ICDECOMPRESS_NOTKEYFRAME | ICDECOMPRESS_HURRYUP;
; 371  : 				m_biInFormat.biSizeImage = pCurrFrameIndex->dwChunkLength;

	mov	eax, DWORD PTR [ecx+ebx+12]

; 372  : 				dwFlags |= (m_biInFormat.biSizeImage) ? 0 : ICDECOMPRESS_NULLFRAME;
; 373  : 
; 374  : 				res = ICDecompress(m_aviIC, dwFlags, &m_biInFormat, (m_pMovieData + pCurrFrameIndex->dwChunkOffset + 8) /*m_pCompressedBuf*/, &m_biOutFormat, m_pDecompressedBuf);

	mov	edx, DWORD PTR [esi+16]
	push	edx
	add	ecx, ebx
	mov	DWORD PTR [esi+80], eax
	mov	ecx, DWORD PTR [ecx+8]
	neg	eax
	lea	edx, DWORD PTR [esi+20]
	push	edx
	mov	edx, DWORD PTR [esi+8]
	sbb	eax, eax
	lea	ecx, DWORD PTR [ecx+edx+8]
	mov	edx, DWORD PTR [esi+12]
	push	ecx
	and	eax, -268435456				; f0000000H
	add	eax, 268435456				; 10000000H
	lea	ecx, DWORD PTR [esi+60]
	push	ecx
	or	eax, -1476395008			; a8000000H
	push	eax
	push	edx
	call	_ICDecompress
	add	esp, 24					; 00000018H

; 375  : 				if( ICERR_OK != res && ICERR_DONTDRAW != res ) {	// проверка на ICERR_DONTDRAW введена из-за indeo 5.11

	test	eax, eax
	je	SHORT $LN19@PreRoll
	cmp	eax, 1
	je	SHORT $LN19@PreRoll

; 376  : 
; 377  : 					R_ASSERT( 0 );

	cmp	BYTE PTR ?ignore_always@?BA@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA, 0
	jne	SHORT $LN19@PreRoll
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BA@??PreRoll@CAviPlayerCustom@@IAEXK@Z@4_NA
	push	OFFSET ??_C@_0BK@JPNAEOKM@CAviPlayerCustom?3?3PreRoll?$AA@
	push	377					; 00000179H
	push	OFFSET ??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@
	call	edi
$LN19@PreRoll:
	add	ebx, 16					; 00000010H
	sub	ebp, 1
	jne	SHORT $LL25@PreRoll
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 413  : 		}
; 414  : 	} // for(...
; 415  : 
; 416  : }

	ret	4
?PreRoll@CAviPlayerCustom@@IAEXK@Z ENDP			; CAviPlayerCustom::PreRoll
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1CAviPlayerCustom@@QAE@XZ
_TEXT	SEGMENT
??1CAviPlayerCustom@@QAE@XZ PROC			; CAviPlayerCustom::~CAviPlayerCustom, COMDAT
; _this$ = ecx

; 16   : {

	push	esi
	mov	esi, ecx

; 17   : 	if( m_aviIC ) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	push	edi
	je	SHORT $LN4@CAviPlayer

; 18   : 
; 19   : 		ICDecompressEnd( m_aviIC );

	push	0
	push	0
	push	16398					; 0000400eH
	push	eax
	call	_ICSendMessage@16

; 20   : 		ICClose( m_aviIC );

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	_ICClose@4
$LN4@CAviPlayer:

; 21   : 	}
; 22   : 
; 23   : 	if( m_pDecompressedBuf )	xr_free( m_pDecompressedBuf );

	cmp	DWORD PTR [esi+16], 0
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN7@CAviPlayer
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN7@CAviPlayer
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
	mov	DWORD PTR [esi+16], 0
$LN7@CAviPlayer:

; 24   : 
; 25   : 	if( m_pMovieData )	xr_free( m_pMovieData );

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN10@CAviPlayer
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@CAviPlayer
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
	mov	DWORD PTR [esi+8], 0
$LN10@CAviPlayer:

; 26   : 	if( m_pMovieIndex ) xr_free( m_pMovieIndex );

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN13@CAviPlayer
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN13@CAviPlayer
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
	mov	DWORD PTR [esi+4], 0
$LN13@CAviPlayer:

; 27   : 
; 28   : 	xr_delete(alpha);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN16@CAviPlayer
	call	??1CAviPlayerCustom@@QAE@XZ		; CAviPlayerCustom::~CAviPlayerCustom
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi
	mov	DWORD PTR [esi], 0
$LN16@CAviPlayer:
	pop	edi
	pop	esi

; 29   : }

	ret	0
??1CAviPlayerCustom@@QAE@XZ ENDP			; CAviPlayerCustom::~CAviPlayerCustom
_TEXT	ENDS
PUBLIC	??0CAviPlayerCustom@@QAE@XZ			; CAviPlayerCustom::CAviPlayerCustom
; Function compile flags: /Ogtpy
;	COMDAT ??0CAviPlayerCustom@@QAE@XZ
_TEXT	SEGMENT
??0CAviPlayerCustom@@QAE@XZ PROC			; CAviPlayerCustom::CAviPlayerCustom, COMDAT
; _this$ = ecx

; 10   : 	ZeroMemory( this, sizeof(*this) );

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	128					; 00000080H
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax+12]
	push	0
	push	esi
	call	ecx

; 11   : 	m_dwFrameCurrent	= 0xfffffffd;	// страхуемся от 0xffffffff + 1 == 0

	mov	DWORD PTR [esi+112], -3			; fffffffdH

; 12   : 	m_dwFirstFrameOffset=0;

	mov	DWORD PTR [esi+116], 0

; 13   : }

	mov	eax, esi
	pop	esi
	ret	0
??0CAviPlayerCustom@@QAE@XZ ENDP			; CAviPlayerCustom::CAviPlayerCustom
_TEXT	ENDS
PUBLIC	??4CAviPlayerCustom@@QAEAAV0@ABV0@@Z		; CAviPlayerCustom::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CAviPlayerCustom@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CAviPlayerCustom@@QAEAAV0@ABV0@@Z PROC		; CAviPlayerCustom::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	push	edi
	mov	eax, ecx
	mov	ecx, 32					; 00000020H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	ret	4
??4CAviPlayerCustom@@QAEAAV0@ABV0@@Z ENDP		; CAviPlayerCustom::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??_GCAviPlayerCustom@@QAEPAXI@Z
_TEXT	SEGMENT
??_GCAviPlayerCustom@@QAEPAXI@Z PROC			; CAviPlayerCustom::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	ecx, esi
	call	??1CAviPlayerCustom@@QAE@XZ		; CAviPlayerCustom::~CAviPlayerCustom
	mov	eax, esi
	ret	0
??_GCAviPlayerCustom@@QAEPAXI@Z ENDP			; CAviPlayerCustom::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
_TEXT	ENDS
;	COMDAT ??$xr_new@VCAviPlayerCustom@@@@YAPAVCAviPlayerCustom@@XZ
_TEXT	SEGMENT
??$xr_new@VCAviPlayerCustom@@@@YAPAVCAviPlayerCustom@@XZ PROC ; xr_new<CAviPlayerCustom>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	128					; 00000080H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	esi, eax
	test	esi, esi
	je	SHORT $LN3@xr_new@3
	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	128					; 00000080H
	push	0
	push	esi
	call	ecx
	mov	DWORD PTR [esi+112], -3			; fffffffdH
	mov	DWORD PTR [esi+116], 0
	mov	eax, esi
	pop	esi

; 70   : }

	ret	0
$LN3@xr_new@3:

; 69   : 	return new (ptr) T();

	xor	eax, eax
	pop	esi

; 70   : }

	ret	0
??$xr_new@VCAviPlayerCustom@@@@YAPAVCAviPlayerCustom@@XZ ENDP ; xr_new<CAviPlayerCustom>
_TEXT	ENDS
PUBLIC	?CalcFrame@CAviPlayerCustom@@IAEKXZ		; CAviPlayerCustom::CalcFrame
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\tntqavi.cpp
;	COMDAT ?CalcFrame@CAviPlayerCustom@@IAEKXZ
_TEXT	SEGMENT
tv140 = -10						; size = 2
tv147 = -8						; size = 4
tv137 = -8						; size = 4
tv135 = -8						; size = 8
?CalcFrame@CAviPlayerCustom@@IAEKXZ PROC		; CAviPlayerCustom::CalcFrame, COMDAT
; _this$ = ecx

; 433  : 	{	

	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 434  : 		if(0==m_dwFirstFrameOffset)

	cmp	DWORD PTR [esi+116], 0
	jne	SHORT $LN1@CalcFrame

; 435  : 			m_dwFirstFrameOffset = RDEVICE.dwTimeContinual-1;

	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+44
	add	eax, -1
	mov	DWORD PTR [esi+116], eax
$LN1@CalcFrame:

; 436  : 
; 437  : 	return DWORD( floor( (RDEVICE.dwTimeContinual-m_dwFirstFrameOffset) * m_fCurrentRate / 1000.0f) ) % m_dwFrameTotal;

	mov	ecx, DWORD PTR ?Device@@3VCRenderDevice@@A+44
	sub	ecx, DWORD PTR [esi+116]
	test	ecx, ecx
	mov	DWORD PTR tv147[esp+16], ecx
	fild	DWORD PTR tv147[esp+16]
	jge	SHORT $LN8@CalcFrame
	fadd	DWORD PTR __real@4f800000
$LN8@CalcFrame:
	fmul	DWORD PTR [esi+104]
	push	ecx
	fmul	DWORD PTR _EPS_L
	fstp	DWORD PTR [esp]
	call	_floorf
	fnstcw	WORD PTR tv140[esp+20]
	add	esp, 4
	movzx	eax, WORD PTR tv140[esp+16]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv137[esp+16], eax
	xor	edx, edx
	fldcw	WORD PTR tv137[esp+16]
	fistp	QWORD PTR tv135[esp+16]
	mov	eax, DWORD PTR tv135[esp+16]
	div	DWORD PTR [esi+108]
	fldcw	WORD PTR tv140[esp+16]
	pop	esi
	mov	eax, edx

; 438  : }

	add	esp, 12					; 0000000cH
	ret	0
?CalcFrame@CAviPlayerCustom@@IAEKXZ ENDP		; CAviPlayerCustom::CalcFrame
_TEXT	ENDS
PUBLIC	?Load@CAviPlayerCustom@@QAEHPAD@Z		; CAviPlayerCustom::Load
; Function compile flags: /Ogtpy
;	COMDAT ?Load@CAviPlayerCustom@@QAEHPAD@Z
_TEXT	SEGMENT
_aviFile$ = -736					; size = 4
_mmckinfoParent$ = -732					; size = 20
_mmckinfoSubchunk$ = -712				; size = 20
tv625 = -692						; size = 4
tv623 = -692						; size = 4
_aviInfo$ = -688					; size = 108
_strh$ = -576						; size = 56
_aname$ = -520						; size = 520
_fname$ = 8						; size = 4
?Load@CAviPlayerCustom@@QAEHPAD@Z PROC			; CAviPlayerCustom::Load, COMDAT
; _this$ = ecx

; 33   : {

	sub	esp, 736				; 000002e0H
	push	ebx
	push	ebp
	push	esi

; 34   : 	// Check for alpha
; 35   : 	string_path		aname;
; 36   : 	strconcat		(sizeof(aname),aname,fname,"_alpha");

	mov	esi, DWORD PTR _fname$[esp+744]
	push	edi
	push	OFFSET ??_C@_06HJHJJPIO@_alpha?$AA@
	push	esi
	lea	eax, DWORD PTR _aname$[esp+760]
	push	eax
	push	520					; 00000208H
	mov	edi, ecx
	call	DWORD PTR __imp_?strconcat@@YAPADHPADPBD1@Z

; 37   : 	if (FS.exist(aname))	

	mov	edx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR _aname$[esp+752]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?exist@CLocatorAPI@@QAEPBUfile@1@PBD@Z
	test	eax, eax
	je	SHORT $LN39@Load@2

; 38   : 	{
; 39   : 		alpha		= xr_new<CAviPlayerCustom>	();

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	128					; 00000080H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN44@Load@2
	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	128					; 00000080H
	push	0
	push	ebx
	call	ecx
	mov	DWORD PTR [ebx+112], -3			; fffffffdH
	mov	DWORD PTR [ebx+116], 0
	jmp	SHORT $LN45@Load@2
$LN44@Load@2:
	xor	ebx, ebx
$LN45@Load@2:

; 40   : 		alpha->Load	(aname);

	lea	edx, DWORD PTR _aname$[esp+752]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR [edi], ebx
	call	?Load@CAviPlayerCustom@@QAEHPAD@Z	; CAviPlayerCustom::Load
$LN39@Load@2:

; 41   : 	}
; 42   : 
; 43   : 	// Открыть через mmioOpen( ) AVI файл
; 44   : 	HMMIO hmmioFile = mmioOpen( fname, NULL, MMIO_READ /*MMIO_EXCLUSIVE*/ );

	push	0
	push	0
	push	esi
	call	DWORD PTR __imp__mmioOpenA@12
	mov	ebp, eax

; 45   : 	if( hmmioFile == NULL ) {

	test	ebp, ebp

; 46   : 
; 47   : 		return FALSE;

	je	$LN60@Load@2

; 48   : 	}
; 49   : 
; 50   : 	// Найти чанк FOURCC('movi')
; 51   : 
; 52   : 	MMCKINFO mmckinfoParent;
; 53   : 	ZeroMemory( &mmckinfoParent, sizeof(mmckinfoParent) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	20					; 00000014H
	push	0
	lea	eax, DWORD PTR _mmckinfoParent$[esp+760]
	push	eax
	call	edx

; 54   : 	mmckinfoParent.fccType = mmioFOURCC('A', 'V', 'I', ' ');
; 55   : 	MMRESULT res;
; 56   : 	if( MMSYSERR_NOERROR != (res = mmioDescend(hmmioFile, &mmckinfoParent, NULL, MMIO_FINDRIFF)) ) {

	mov	ebx, DWORD PTR __imp__mmioDescend@16
	push	32					; 00000020H
	push	0
	lea	eax, DWORD PTR _mmckinfoParent$[esp+760]
	push	eax
	push	ebp
	mov	DWORD PTR _mmckinfoParent$[esp+776], 541677121 ; 20495641H
	call	ebx
	test	eax, eax

; 57   : 
; 58   : 		mmioClose( hmmioFile, 0 );
; 59   : 		return FALSE;

	jne	$LN17@Load@2

; 60   : 	}
; 61   : 
; 62   : 	ZeroMemory( &mmckinfoParent, sizeof(mmckinfoParent) );

	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR _mmckinfoParent$[esp+760]
	push	ecx
	call	eax

; 63   : 	mmckinfoParent.fccType = mmioFOURCC('h', 'd', 'r', 'l'); 
; 64   : 	if( MMSYSERR_NOERROR != (res = mmioDescend(hmmioFile, &mmckinfoParent, NULL, MMIO_FINDLIST)) ) {

	push	64					; 00000040H
	push	0
	lea	ecx, DWORD PTR _mmckinfoParent$[esp+760]
	push	ecx
	push	ebp
	mov	DWORD PTR _mmckinfoParent$[esp+776], 1819436136 ; 6c726468H
	call	ebx
	test	eax, eax

; 65   : 
; 66   : 		mmioClose( hmmioFile, 0 );
; 67   : 		return FALSE;

	jne	$LN17@Load@2

; 68   : 	}
; 69   : //-------------------------------------------------------------------
; 70   : 	//++strl
; 71   : 	ZeroMemory( &mmckinfoParent, sizeof(mmckinfoParent) );

	push	20					; 00000014H
	push	eax
	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	lea	edx, DWORD PTR _mmckinfoParent$[esp+760]
	push	edx
	call	ecx

; 72   : 	mmckinfoParent.fccType = mmioFOURCC('s', 't', 'r', 'l'); 
; 73   : 	if( MMSYSERR_NOERROR != (res = mmioDescend(hmmioFile, &mmckinfoParent, NULL, MMIO_FINDLIST)) ) {

	push	64					; 00000040H
	push	0
	lea	edx, DWORD PTR _mmckinfoParent$[esp+760]
	push	edx
	push	ebp
	mov	DWORD PTR _mmckinfoParent$[esp+776], 1819440243 ; 6c727473H
	call	ebx
	test	eax, eax

; 74   : 
; 75   : 		mmioClose( hmmioFile, 0 );
; 76   : 		return FALSE;

	jne	$LN17@Load@2

; 77   : 	}
; 78   : 
; 79   : 	//++strh
; 80   : 	ZeroMemory( &mmckinfoParent, sizeof(mmckinfoParent) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	20					; 00000014H
	push	eax
	lea	eax, DWORD PTR _mmckinfoParent$[esp+760]
	push	eax
	call	edx

; 81   : 	mmckinfoParent.fccType = mmioFOURCC('s', 't', 'r', 'h'); 
; 82   : 	if( MMSYSERR_NOERROR != (res = mmioDescend(hmmioFile, &mmckinfoParent, NULL, MMIO_FINDCHUNK)) ) {

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _mmckinfoParent$[esp+760]
	push	eax
	push	ebp
	mov	DWORD PTR _mmckinfoParent$[esp+776], 1752331379 ; 68727473H
	call	ebx
	test	eax, eax

; 83   : 
; 84   : 		mmioClose( hmmioFile, 0 );
; 85   : 		return FALSE;

	jne	$LN17@Load@2

; 86   : 	}
; 87   : 
; 88   : 	AVIStreamHeaderCustom	strh;
; 89   : 	ZeroMemory( &strh, sizeof(strh) );

	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	56					; 00000038H
	push	eax
	mov	eax, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR _strh$[esp+760]
	push	ecx
	call	eax

; 90   : 	if( mmckinfoParent.cksize != (DWORD)mmioRead(hmmioFile, (HPSTR)&strh, mmckinfoParent.cksize) ) {

	mov	ecx, DWORD PTR _mmckinfoParent$[esp+756]
	push	ecx
	lea	edx, DWORD PTR _strh$[esp+756]
	push	edx
	push	ebp
	call	DWORD PTR __imp__mmioRead@12
	cmp	DWORD PTR _mmckinfoParent$[esp+756], eax

; 91   : 
; 92   : 		mmioClose( hmmioFile, 0 );
; 93   : 		return FALSE;

	jne	$LN17@Load@2

; 94   : 	}
; 95   : 
; 96   : 
; 97   : 
; 98   :     AVIFileInit		();

	call	_AVIFileInit@0

; 99   : 	PAVIFILE aviFile = 0;
; 100  : 	if( AVIERR_OK != AVIFileOpen( &aviFile, fname, OF_READ, 0 ) )	return FALSE;

	push	0
	push	0
	push	esi
	lea	eax, DWORD PTR _aviFile$[esp+764]
	push	eax
	mov	DWORD PTR _aviFile$[esp+768], 0
	call	_AVIFileOpenA@16
	test	eax, eax
	jne	$LN60@Load@2

; 101  : 
; 102  : 	AVIFILEINFO		aviInfo;
; 103  : 	ZeroMemory		(&aviInfo,sizeof(aviInfo));

	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	108					; 0000006cH
	push	eax
	mov	eax, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR _aviInfo$[esp+760]
	push	ecx
	call	eax

; 104  : 	if( AVIERR_OK != AVIFileInfo( aviFile, &aviInfo, sizeof(aviInfo) ) ){

	mov	edx, DWORD PTR _aviFile$[esp+752]
	push	108					; 0000006cH
	lea	ecx, DWORD PTR _aviInfo$[esp+756]
	push	ecx
	push	edx
	call	_AVIFileInfoA@12
	test	eax, eax
	je	SHORT $LN31@Load@2

; 105  : 		AVIFileRelease( aviFile );

	mov	eax, DWORD PTR _aviFile$[esp+752]
	push	eax
	call	_AVIFileRelease@4

; 192  : 		return FALSE;

	xor	eax, eax

; 254  : 	}
; 255  : 
; 256  : //-----------------------------------------------------------------
; 257  : 	return TRUE;
; 258  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 736				; 000002e0H
	ret	4
$LN31@Load@2:

; 106  : 		return FALSE;
; 107  : 	}
; 108  : 
; 109  : 	m_dwFrameTotal	= aviInfo.dwLength;
; 110  : 	m_fCurrentRate	= (float) aviInfo.dwRate / (float)aviInfo.dwScale;

	mov	edx, DWORD PTR _aviInfo$[esp+784]
	fild	DWORD PTR _aviInfo$[esp+784]
	test	edx, edx
	mov	ecx, DWORD PTR _aviInfo$[esp+788]
	mov	DWORD PTR [edi+108], ecx
	jge	SHORT $LN58@Load@2
	fadd	DWORD PTR __real@4f800000
$LN58@Load@2:
	mov	eax, DWORD PTR _aviInfo$[esp+780]
	fild	DWORD PTR _aviInfo$[esp+780]
	test	eax, eax
	jge	SHORT $LN59@Load@2
	fadd	DWORD PTR __real@4f800000
$LN59@Load@2:
	fdivp	ST(1), ST(0)

; 111  : 
; 112  : 	m_dwWidth			= aviInfo.dwWidth;
; 113  : 	m_dwHeight		= aviInfo.dwHeight;
; 114  : 
; 115  : 	AVIFileRelease( aviFile );

	mov	eax, DWORD PTR _aviFile$[esp+752]
	mov	ecx, DWORD PTR _aviInfo$[esp+772]
	mov	edx, DWORD PTR _aviInfo$[esp+776]
	push	eax
	mov	DWORD PTR [edi+120], ecx
	mov	DWORD PTR [edi+124], edx
	fstp	DWORD PTR [edi+104]
	call	_AVIFileRelease@4

; 116  : 
; 117  : 	R_ASSERT			( m_dwWidth && m_dwHeight );

	cmp	BYTE PTR ?ignore_always@?BO@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA, 0
	jne	SHORT $LN29@Load@2
	cmp	DWORD PTR [edi+120], 0
	je	SHORT $LN26@Load@2
	cmp	DWORD PTR [edi+124], 0
	jne	SHORT $LN29@Load@2
$LN26@Load@2:
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BO@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA
	push	OFFSET ??_C@_0BH@PAAIHHNJ@CAviPlayerCustom?3?3Load?$AA@
	push	117					; 00000075H
	push	OFFSET ??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0BI@HBNFHHDI@m_dwWidth?5?$CG?$CG?5m_dwHeight?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN29@Load@2:

; 118  : 
; 119  : 	m_pDecompressedBuf	= (BYTE *)xr_malloc( m_dwWidth * m_dwHeight * 4 + 4);

	mov	eax, DWORD PTR [edi+124]
	imul	eax, DWORD PTR [edi+120]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax*4+4]
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 120  : 
; 121  : 	//++strf
; 122  : 	ZeroMemory( &mmckinfoParent, sizeof(mmckinfoParent) );

	push	20					; 00000014H
	mov	DWORD PTR [edi+16], eax
	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	push	0
	lea	ecx, DWORD PTR _mmckinfoParent$[esp+760]
	push	ecx
	call	eax

; 123  : 	mmckinfoParent.fccType = mmioFOURCC('s', 't', 'r', 'f'); 
; 124  : 	if( MMSYSERR_NOERROR != (res = mmioDescend(hmmioFile, &mmckinfoParent, NULL, MMIO_FINDCHUNK)) ) {

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _mmckinfoParent$[esp+760]
	push	ecx
	push	ebp
	mov	DWORD PTR _mmckinfoParent$[esp+776], 1718776947 ; 66727473H
	call	ebx
	test	eax, eax

; 125  : 
; 126  : 		mmioClose( hmmioFile, 0 );
; 127  : 		return FALSE;

	jne	$LN17@Load@2

; 128  : 	}
; 129  : 
; 130  : 	// получаем входной формат декомпрессора в BITMAPINFOHEADER
; 131  : 	if( mmckinfoParent.cksize != (DWORD)mmioRead(hmmioFile, (HPSTR)&m_biInFormat, mmckinfoParent.cksize) ) {

	mov	edx, DWORD PTR _mmckinfoParent$[esp+756]
	push	edx
	lea	esi, DWORD PTR [edi+60]
	push	esi
	push	ebp
	call	DWORD PTR __imp__mmioRead@12
	cmp	DWORD PTR _mmckinfoParent$[esp+756], eax

; 132  : 
; 133  : 		mmioClose( hmmioFile, 0 );
; 134  : 		return FALSE;

	jne	$LN17@Load@2

; 135  : 	}
; 136  : 
; 137  : 	// создаем выходной формат декомпрессора	(xRGB)
; 138  : 	m_biOutFormat.biSize	= sizeof( m_biOutFormat );
; 139  : 	m_biOutFormat.biBitCount= 32;
; 140  : 	m_biOutFormat.biCompression	= BI_RGB;
; 141  : 	m_biOutFormat.biPlanes	= 1;
; 142  : 	m_biOutFormat.biWidth	= m_dwWidth;
; 143  : 	m_biOutFormat.biHeight	= m_dwHeight;

	mov	eax, DWORD PTR [edi+124]
	mov	ecx, DWORD PTR [edi+120]
	mov	DWORD PTR [edi+28], eax

; 144  : 	m_biOutFormat.biSizeImage = m_dwWidth * m_dwHeight * 4;

	imul	eax, ecx

; 145  : 
; 146  : 	// Найти подходящий декомпрессор
; 147  : 	m_aviIC = ICLocate( ICTYPE_VIDEO, NULL, &m_biInFormat, &m_biOutFormat, \
; 148  : 						// ICMODE_DECOMPRESS
; 149  : 						ICMODE_FASTDECOMPRESS
; 150  : 						);

	push	3
	lea	ebx, DWORD PTR [edi+20]
	push	ebx
	push	esi
	add	eax, eax
	push	0
	add	eax, eax
	push	1667524982				; 63646976H
	mov	DWORD PTR [ebx], 40			; 00000028H
	mov	WORD PTR [edi+34], 32			; 00000020H
	mov	DWORD PTR [edi+36], 0
	mov	WORD PTR [edi+32], 1
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+40], eax
	call	_ICLocate@20

; 151  : 	if( m_aviIC == 0 ) {

	test	eax, eax
	mov	DWORD PTR [edi+12], eax

; 152  : 
; 153  : 		return FALSE;

	je	$LN60@Load@2

; 154  : 	}
; 155  : 
; 156  : 	// Проинитить декомпрессор
; 157  : 	if( ICERR_OK != ICDecompressBegin(m_aviIC, &m_biInFormat, &m_biOutFormat) ) {

	push	ebx
	push	esi
	push	16396					; 0000400cH
	push	eax
	call	_ICSendMessage@16
	test	eax, eax

; 158  : 
; 159  : 		return FALSE;

	jne	$LN60@Load@2

; 160  : 	}
; 161  : 
; 162  : 	//--strf
; 163  : 	if( MMSYSERR_NOERROR != mmioAscend( hmmioFile, &mmckinfoParent, 0 ) ) {

	mov	esi, DWORD PTR __imp__mmioAscend@12
	push	eax
	lea	eax, DWORD PTR _mmckinfoParent$[esp+756]
	push	eax
	push	ebp
	call	esi
	test	eax, eax

; 164  : 
; 165  : 		mmioClose( hmmioFile, 0 );

	push	0

; 166  : 		return FALSE;

	jne	$LN61@Load@2

; 167  : 	}
; 168  : 
; 169  : 	//--strh
; 170  : 	if( MMSYSERR_NOERROR != mmioAscend( hmmioFile, &mmckinfoParent, 0 ) ) {

	lea	ecx, DWORD PTR _mmckinfoParent$[esp+756]
	push	ecx
	push	ebp
	call	esi
	test	eax, eax

; 171  : 
; 172  : 		mmioClose( hmmioFile, 0 );

	push	0

; 173  : 		return FALSE;

	jne	$LN61@Load@2

; 174  : 	}
; 175  : 
; 176  : 	//--strl
; 177  : 	if( MMSYSERR_NOERROR != mmioAscend( hmmioFile, &mmckinfoParent, 0 ) ) {

	lea	edx, DWORD PTR _mmckinfoParent$[esp+756]
	push	edx
	push	ebp
	call	esi
	test	eax, eax

; 178  : 
; 179  : 		mmioClose( hmmioFile, 0 );
; 180  : 		return FALSE;

	jne	$LN17@Load@2

; 181  : 	}
; 182  : 
; 183  : //-------------------------------------------------------------------
; 184  : 	MMCKINFO mmckinfoSubchunk;
; 185  : 	ZeroMemory( &mmckinfoSubchunk, sizeof(mmckinfoSubchunk) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	20					; 00000014H
	push	eax
	lea	eax, DWORD PTR _mmckinfoSubchunk$[esp+760]
	push	eax
	call	edx

; 186  : 	mmckinfoSubchunk.fccType = mmioFOURCC('m', 'o', 'v', 'i'); 
; 187  : 	if( MMSYSERR_NOERROR != (res = mmioDescend(hmmioFile, &mmckinfoSubchunk, NULL, MMIO_FINDLIST)) \
; 188  : 		|| mmckinfoSubchunk.cksize <= 4 )

	push	64					; 00000040H
	push	0
	lea	eax, DWORD PTR _mmckinfoSubchunk$[esp+760]
	push	eax
	push	ebp
	mov	DWORD PTR _mmckinfoSubchunk$[esp+776], 1769369453 ; 69766f6dH
	call	DWORD PTR __imp__mmioDescend@16
	test	eax, eax
	jne	$LN17@Load@2
	cmp	DWORD PTR _mmckinfoSubchunk$[esp+756], 4
	jbe	$LN17@Load@2

; 193  : 	}
; 194  : 
; 195  : 	mmioSeek( hmmioFile, mmckinfoSubchunk.dwDataOffset, SEEK_SET );

	mov	ecx, DWORD PTR _mmckinfoSubchunk$[esp+764]
	push	eax
	push	ecx
	push	ebp
	call	DWORD PTR __imp__mmioSeek@12

; 196  : 	
; 197  : 	// Выделить память под сжатые  данные всего клипа
; 198  : 	m_pMovieData = (BYTE *)xr_malloc( mmckinfoSubchunk.cksize );

	mov	edx, DWORD PTR _mmckinfoSubchunk$[esp+756]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	esi, DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	push	edx
	call	esi

; 199  : 	if( m_pMovieData == NULL ) {

	test	eax, eax
	lea	ebx, DWORD PTR [edi+8]
	mov	DWORD PTR [ebx], eax

; 200  : 
; 201  : 		mmioClose( hmmioFile, 0 );
; 202  : 		return FALSE;

	je	$LN17@Load@2

; 203  : 	}
; 204  : 
; 205  : 	if( mmckinfoSubchunk.cksize != (DWORD)mmioRead( hmmioFile, (HPSTR)m_pMovieData, mmckinfoSubchunk.cksize ) ) {

	mov	ecx, DWORD PTR _mmckinfoSubchunk$[esp+756]
	push	ecx
	push	eax
	push	ebp
	call	DWORD PTR __imp__mmioRead@12
	cmp	DWORD PTR _mmckinfoSubchunk$[esp+756], eax

; 206  : 
; 207  : 		xr_free( m_pMovieData );	m_pMovieData	= NULL;
; 208  : 		mmioClose( hmmioFile, 0 );
; 209  : 		return FALSE;

	jne	SHORT $LN12@Load@2

; 210  : 	}
; 211  : 
; 212  : 	if( MMSYSERR_NOERROR != mmioAscend( hmmioFile, &mmckinfoSubchunk, 0 ) ) {

	push	0
	lea	edx, DWORD PTR _mmckinfoSubchunk$[esp+756]
	push	edx
	push	ebp
	call	DWORD PTR __imp__mmioAscend@12
	test	eax, eax

; 213  : 
; 214  : 		xr_free( m_pMovieData );	m_pMovieData	= NULL;
; 215  : 		mmioClose( hmmioFile, 0 );
; 216  : 		return FALSE;

	jne	SHORT $LN12@Load@2

; 217  : 	}
; 218  : 
; 219  : 	// Найти чанк FOURCC('idx1')
; 220  : 	ZeroMemory( &mmckinfoSubchunk, sizeof(mmckinfoSubchunk) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	20					; 00000014H
	push	eax
	lea	eax, DWORD PTR _mmckinfoSubchunk$[esp+760]
	push	eax
	call	edx

; 221  : 	mmckinfoSubchunk.fccType = mmioFOURCC('i', 'd', 'x', '1'); 
; 222  : 
; 223  : 	if( MMSYSERR_NOERROR != (res = mmioDescend(hmmioFile, &mmckinfoSubchunk, NULL, MMIO_FINDCHUNK)) \
; 224  : 		|| mmckinfoSubchunk.cksize <= 4 )

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _mmckinfoSubchunk$[esp+760]
	push	eax
	push	ebp
	mov	DWORD PTR _mmckinfoSubchunk$[esp+776], 829973609 ; 31786469H
	call	DWORD PTR __imp__mmioDescend@16
	test	eax, eax
	jne	SHORT $LN12@Load@2
	mov	eax, DWORD PTR _mmckinfoSubchunk$[esp+756]
	cmp	eax, 4
	jbe	SHORT $LN12@Load@2

; 225  : 	{
; 226  : 		xr_free( m_pMovieData );	m_pMovieData	= NULL;
; 227  : 		mmioClose( hmmioFile, 0 );
; 228  : 		return FALSE;
; 229  : 	}
; 230  : 
; 231  : 	// Выделить память под индекс
; 232  : 	m_pMovieIndex = (AVIINDEXENTRY *)xr_malloc( mmckinfoSubchunk.cksize );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi

; 233  : 	if( m_pMovieIndex == NULL ) {

	test	eax, eax
	lea	esi, DWORD PTR [edi+4]
	mov	DWORD PTR [esi], eax

; 234  : 
; 235  : 		xr_free( m_pMovieData );	m_pMovieData	= NULL;
; 236  : 		mmioClose( hmmioFile, 0 );
; 237  : 		return FALSE;

	je	SHORT $LN12@Load@2

; 238  : 	}
; 239  : 
; 240  : 	if( mmckinfoSubchunk.cksize != (DWORD)mmioRead( hmmioFile, (HPSTR)m_pMovieIndex, mmckinfoSubchunk.cksize ) ) {

	mov	ecx, DWORD PTR _mmckinfoSubchunk$[esp+756]
	push	ecx
	push	eax
	push	ebp
	call	DWORD PTR __imp__mmioRead@12
	cmp	DWORD PTR _mmckinfoSubchunk$[esp+756], eax
	je	SHORT $LN10@Load@2

; 241  : 
; 242  : 		xr_free( m_pMovieIndex );	m_pMovieIndex	= NULL;

	call	??$xr_free@UAVIINDEXENTRY@@@@YAXAAPAUAVIINDEXENTRY@@@Z ; xr_free<AVIINDEXENTRY>
	mov	DWORD PTR [esi], 0
$LN12@Load@2:
	mov	esi, ebx
	call	??$xr_free@E@@YAXAAPAE@Z		; xr_free<unsigned char>
	mov	DWORD PTR [ebx], 0
$LN17@Load@2:

; 189  : 	{
; 190  : 
; 191  : 		mmioClose( hmmioFile, 0 );

	push	0
$LN61@Load@2:
	push	ebp
	call	DWORD PTR __imp__mmioClose@8
$LN60@Load@2:

; 192  : 		return FALSE;

	xor	eax, eax

; 254  : 	}
; 255  : 
; 256  : //-----------------------------------------------------------------
; 257  : 	return TRUE;
; 258  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 736				; 000002e0H
	ret	4
$LN10@Load@2:

; 243  : 		xr_free( m_pMovieData );	m_pMovieData	= NULL;
; 244  : 		mmioClose( hmmioFile, 0 );
; 245  : 		return FALSE;
; 246  : 	}
; 247  : 
; 248  : 	// Закрыть AVI файл через mmioClose( )
; 249  : 	mmioClose( hmmioFile, 0 );

	push	0
	push	ebp
	call	DWORD PTR __imp__mmioClose@8

; 250  : 
; 251  : 	if (alpha)	{

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@Load@2

; 252  : 		R_ASSERT(m_dwWidth  == alpha->m_dwWidth	);

	cmp	BYTE PTR ?ignore_always@?EP@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA, 0
	jne	SHORT $LN7@Load@2
	mov	edx, DWORD PTR [edi+120]
	cmp	edx, DWORD PTR [eax+120]
	je	SHORT $LN7@Load@2
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?EP@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA
	push	OFFSET ??_C@_0BH@PAAIHHNJ@CAviPlayerCustom?3?3Load?$AA@
	push	252					; 000000fcH
	push	OFFSET ??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0BO@KLKFEPLC@m_dwWidth?5?$DN?$DN?5alpha?9?$DOm_dwWidth?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN7@Load@2:

; 253  : 		R_ASSERT(m_dwHeight == alpha->m_dwHeight);

	cmp	BYTE PTR ?ignore_always@?FD@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA, 0
	jne	SHORT $LN2@Load@2
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+124]
	cmp	ecx, DWORD PTR [eax+124]
	je	SHORT $LN2@Load@2
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?FD@??Load@CAviPlayerCustom@@QAEHPAD@Z@4_NA
	push	OFFSET ??_C@_0BH@PAAIHHNJ@CAviPlayerCustom?3?3Load?$AA@
	push	253					; 000000fdH
	push	OFFSET ??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0CA@LPKIBLFL@m_dwHeight?5?$DN?$DN?5alpha?9?$DOm_dwHeight?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN2@Load@2:

; 254  : 	}
; 255  : 
; 256  : //-----------------------------------------------------------------
; 257  : 	return TRUE;
; 258  : }

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1
	pop	ebx
	add	esp, 736				; 000002e0H
	ret	4
?Load@CAviPlayerCustom@@QAEHPAD@Z ENDP			; CAviPlayerCustom::Load
_TEXT	ENDS
PUBLIC	?NeedUpdate@CAviPlayerCustom@@QAEHXZ		; CAviPlayerCustom::NeedUpdate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\tntqavi.h
;	COMDAT ?NeedUpdate@CAviPlayerCustom@@QAEHXZ
_TEXT	SEGMENT
?NeedUpdate@CAviPlayerCustom@@QAEHXZ PROC		; CAviPlayerCustom::NeedUpdate, COMDAT
; _this$ = ecx

; 99   : 	BOOL				NeedUpdate			( ) { return CalcFrame( ) != m_dwFrameCurrent; }

	push	esi
	mov	esi, ecx
	call	?CalcFrame@CAviPlayerCustom@@IAEKXZ	; CAviPlayerCustom::CalcFrame
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+112]
	pop	esi
	setne	cl
	mov	eax, ecx
	ret	0
?NeedUpdate@CAviPlayerCustom@@QAEHXZ ENDP		; CAviPlayerCustom::NeedUpdate
PUBLIC	?GetFrame@CAviPlayerCustom@@QAEHPAPAE@Z		; CAviPlayerCustom::GetFrame
PUBLIC	?DecompressFrame@CAviPlayerCustom@@IAEHK@Z	; CAviPlayerCustom::DecompressFrame
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\tntqavi.cpp
;	COMDAT ?DecompressFrame@CAviPlayerCustom@@IAEHK@Z
_TEXT	SEGMENT
_alpha_buf$122137 = 8					; size = 4
_dwFrameNum$ = 8					; size = 4
?DecompressFrame@CAviPlayerCustom@@IAEHK@Z PROC		; CAviPlayerCustom::DecompressFrame, COMDAT
; _this$ = ecx

; 261  : {

	push	esi
	push	edi

; 262  : 	// получаем элемент индекса
; 263  : 	AVIINDEXENTRY	*pCurrFrameIndex = &m_pMovieIndex[ dwFrameNum ];

	mov	edi, DWORD PTR _dwFrameNum$[esp+4]
	mov	esi, ecx
	shl	edi, 4
	add	edi, DWORD PTR [esi+4]

; 264  : 
; 265  : 	m_biInFormat.biSizeImage = pCurrFrameIndex->dwChunkLength;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+80], eax

; 266  : 	R_ASSERT( m_biInFormat.biSizeImage != 0 );

	cmp	BYTE PTR ?ignore_always@?3??DecompressFrame@CAviPlayerCustom@@IAEHK@Z@4_NA, 0
	jne	SHORT $LN8@Decompress@2
	test	eax, eax
	jne	SHORT $LN8@Decompress@2
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??DecompressFrame@CAviPlayerCustom@@IAEHK@Z@4_NA
	push	OFFSET ??_C@_0CC@OEELJIGN@CAviPlayerCustom?3?3DecompressFram@
	push	266					; 0000010aH
	push	OFFSET ??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0BO@OILNMJHF@m_biInFormat?4biSizeImage?5?$CB?$DN?50?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN8@Decompress@2:

; 267  : 
; 268  : 	DWORD	dwFlags;
; 269  : 	dwFlags = (pCurrFrameIndex->dwFlags & AVIIF_KEYFRAME) ? 0 : ICDECOMPRESS_NOTKEYFRAME;

	mov	ecx, DWORD PTR [edi+4]

; 270  : 	m_biInFormat.biSizeImage = pCurrFrameIndex->dwChunkLength;

	mov	eax, DWORD PTR [edi+12]
	shl	ecx, 23					; 00000017H
	mov	DWORD PTR [esi+80], eax
	not	ecx
	and	ecx, 134217728				; 08000000H

; 271  : 	dwFlags |= (m_biInFormat.biSizeImage) ? 0 : ICDECOMPRESS_NULLFRAME;

	neg	eax
	sbb	eax, eax
	and	eax, -268435456				; f0000000H
	add	eax, 268435456				; 10000000H
	or	ecx, eax

; 272  : 
; 273  : 	if( ICERR_OK != ICDecompress(m_aviIC, dwFlags, &m_biInFormat, (m_pMovieData + pCurrFrameIndex->dwChunkOffset + 8), &m_biOutFormat, m_pDecompressedBuf) ) {

	mov	eax, DWORD PTR [esi+16]
	push	eax
	mov	eax, DWORD PTR [edi+8]
	lea	edx, DWORD PTR [esi+20]
	push	edx
	mov	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax+edx+8]
	push	eax
	mov	eax, DWORD PTR [esi+12]
	lea	edx, DWORD PTR [esi+60]
	push	edx
	push	ecx
	push	eax
	call	_ICDecompress
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN5@Decompress@2
	pop	edi

; 274  : 		return	FALSE;

	xor	eax, eax
	pop	esi

; 294  : }

	ret	4
$LN5@Decompress@2:

; 275  : 	}
; 276  : 
; 277  : 	if (alpha)	{

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1@Decompress@2

; 278  : 		// update
; 279  : 		BYTE*	alpha_buf;
; 280  : 		alpha->GetFrame(&alpha_buf);

	lea	edx, DWORD PTR _alpha_buf$122137[esp+4]
	push	edx
	call	?GetFrame@CAviPlayerCustom@@QAEHPAPAE@Z	; CAviPlayerCustom::GetFrame

; 281  : 		u32*	dst		= (u32*)m_pDecompressedBuf;
; 282  : 		u32*	src		= (u32*)alpha_buf;
; 283  : 		u32*	end		= dst+u32(m_dwWidth*m_dwHeight);

	mov	eax, DWORD PTR [esi+124]
	imul	eax, DWORD PTR [esi+120]
	mov	ecx, DWORD PTR [esi+16]
	mov	edi, DWORD PTR _alpha_buf$122137[esp+4]
	lea	esi, DWORD PTR [ecx+eax*4]

; 284  : 		for (; dst!=end; src++,dst++)

	cmp	ecx, esi
	je	SHORT $LN1@Decompress@2
	push	ebx
	npad	1
$LL3@Decompress@2:

; 285  : 		{
; 286  : 			u32&	d	= *dst;
; 287  : 			u32		s	= *src;

	mov	eax, DWORD PTR [edi]

; 288  : 			u32		a	= (color_get_R(s)+color_get_G(s)+color_get_B(s))/3;
; 289  : 			d			= subst_alpha	(d,a);

	mov	edx, eax
	shr	edx, 16					; 00000010H
	movzx	ebx, ah
	and	edx, 255				; 000000ffH
	movzx	eax, al
	add	edx, ebx
	add	edx, eax
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	mov	eax, DWORD PTR [ecx]
	shr	edx, 1
	shl	edx, 24					; 00000018H
	and	eax, 16777215				; 00ffffffH
	or	edx, eax
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	add	edi, 4
	cmp	ecx, esi
	jne	SHORT $LL3@Decompress@2
	pop	ebx
$LN1@Decompress@2:
	pop	edi

; 290  : 		}
; 291  : 	}
; 292  : 
; 293  : 	return	TRUE;

	mov	eax, 1
	pop	esi

; 294  : }

	ret	4
?DecompressFrame@CAviPlayerCustom@@IAEHK@Z ENDP		; CAviPlayerCustom::DecompressFrame
; Function compile flags: /Ogtpy
;	COMDAT ?GetFrame@CAviPlayerCustom@@QAEHPAPAE@Z
_TEXT	SEGMENT
_pDest$ = 8						; size = 4
?GetFrame@CAviPlayerCustom@@QAEHPAPAE@Z PROC		; CAviPlayerCustom::GetFrame, COMDAT
; _this$ = ecx

; 303  : 	R_ASSERT( pDest );

	cmp	BYTE PTR ?ignore_always@?3??GetFrame@CAviPlayerCustom@@QAEHPAPAE@Z@4_NA, 0
	push	ebx
	mov	ebx, DWORD PTR _pDest$[esp]
	push	esi
	push	edi
	mov	esi, ecx
	jne	SHORT $LN8@GetFrame
	test	ebx, ebx
	jne	SHORT $LN8@GetFrame
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??GetFrame@CAviPlayerCustom@@QAEHPAPAE@Z@4_NA
	push	OFFSET ??_C@_0BL@ELJMIBML@CAviPlayerCustom?3?3GetFrame?$AA@
	push	303					; 0000012fH
	push	OFFSET ??_C@_0DA@ILJAOBLI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_05PJHAMANO@pDest?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN8@GetFrame:

; 304  : 
; 305  : 	DWORD	dwCurrFrame;
; 306  : 	dwCurrFrame	= CalcFrame();

	mov	ecx, esi
	call	?CalcFrame@CAviPlayerCustom@@IAEKXZ	; CAviPlayerCustom::CalcFrame
	mov	edi, eax

; 307  : 
; 308  : //** debug	dwCurrFrame = 112;
; 309  : 
; 310  : 	// Если заданный кадр равен предидущему
; 311  : 	if( dwCurrFrame == m_dwFrameCurrent ) {

	mov	eax, DWORD PTR [esi+112]
	cmp	edi, eax
	jne	SHORT $LN5@GetFrame

; 312  : 
; 313  : 		*pDest				= m_pDecompressedBuf;

	mov	eax, DWORD PTR [esi+16]
	pop	edi
	mov	DWORD PTR [ebx], eax
	pop	esi

; 314  : 
; 315  : 		return	FALSE;

	xor	eax, eax
	pop	ebx

; 344  : 	}
; 345  : }

	ret	4
$LN5@GetFrame:

; 316  : 	} else
; 317  : 	// Если заданный кадр это Предидущий кадр + 1
; 318  : 	if( dwCurrFrame == m_dwFrameCurrent + 1 ) {

	add	eax, 1
	cmp	edi, eax
	jne	SHORT $LN3@GetFrame

; 319  : 	
; 320  : 		++m_dwFrameCurrent;	//	dwCurrFrame == m_dwFrameCurrent + 1
; 321  : 
; 322  : 		*pDest	= m_pDecompressedBuf;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+112], eax
	mov	DWORD PTR [ebx], ecx

; 323  : 
; 324  : 		DecompressFrame( m_dwFrameCurrent );

	mov	edx, DWORD PTR [esi+112]
	push	edx

; 340  : 
; 341  : 		// Декомпрессим заданный кадр
; 342  : 		DecompressFrame( m_dwFrameCurrent );

	mov	ecx, esi
	call	?DecompressFrame@CAviPlayerCustom@@IAEHK@Z ; CAviPlayerCustom::DecompressFrame
	pop	edi
	pop	esi

; 343  : 		return	TRUE;

	mov	eax, 1
	pop	ebx

; 344  : 	}
; 345  : }

	ret	4
$LN3@GetFrame:

; 325  : 		return	TRUE;
; 326  : 	} else {
; 327  : 		
; 328  : 		// Это произвольный кадр
; 329  : 
; 330  : 		if( ! (m_pMovieIndex[ dwCurrFrame ].dwFlags & AVIIF_KEYFRAME) ) {

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, edi
	shl	eax, 4
	test	BYTE PTR [eax+ecx+4], 16		; 00000010H
	jne	SHORT $LN1@GetFrame

; 331  : 
; 332  : 			// Это НЕ ключевой кадр -
; 333  : 			// делаем PreRoll от ближайшего предидущего ключевого кадра до Заданного-1
; 334  : 			PreRoll( dwCurrFrame );

	push	edi
	mov	ecx, esi
	call	?PreRoll@CAviPlayerCustom@@IAEXK@Z	; CAviPlayerCustom::PreRoll
$LN1@GetFrame:

; 335  : 		}			
; 336  : 
; 337  : 		m_dwFrameCurrent	= dwCurrFrame;
; 338  : 		
; 339  : 		*pDest	= m_pDecompressedBuf;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [ebx], edx

; 340  : 
; 341  : 		// Декомпрессим заданный кадр
; 342  : 		DecompressFrame( m_dwFrameCurrent );

	mov	eax, DWORD PTR [esi+112]
	push	eax
	mov	ecx, esi
	call	?DecompressFrame@CAviPlayerCustom@@IAEHK@Z ; CAviPlayerCustom::DecompressFrame
	pop	edi
	pop	esi

; 343  : 		return	TRUE;

	mov	eax, 1
	pop	ebx

; 344  : 	}
; 345  : }

	ret	4
?GetFrame@CAviPlayerCustom@@QAEHPAPAE@Z ENDP		; CAviPlayerCustom::GetFrame
END
