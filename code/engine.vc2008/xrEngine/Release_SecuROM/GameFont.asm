; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\GameFont.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??$__fill_n@PAUString@CGameFont@@IU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@IABU23@@Z ; stlp_std::priv::__fill_n<CGameFont::String *,unsigned int,CGameFont::String>
PUBLIC	?_M_insert_overflow@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_insert_overflow
PUBLIC	??$_Copy_Construct@UString@CGameFont@@@stlp_std@@YAXPAUString@CGameFont@@ABU12@@Z ; stlp_std::_Copy_Construct<CGameFont::String>
PUBLIC	?push_back@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEXABUString@CGameFont@@@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::push_back
PUBLIC	?to_storage_type_cref@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAABUString@CGameFont@@ABU45@@Z ; stlp_std::priv::_CastTraits<CGameFont::String,CGameFont::String>::to_storage_type_cref
PUBLIC	?push_back@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEXABUString@CGameFont@@@Z ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::push_back
PUBLIC	??$vsprintf_s@$0EAA@@@YAHAAY0EAA@DPBDPAD@Z	; vsprintf_s<1024>
PUBLIC	?begin@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@XZ ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::begin
PUBLIC	?end@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@XZ ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::end
PUBLIC	?to_value_type_ptr@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAPAUString@CGameFont@@PAU45@@Z ; stlp_std::priv::_CastTraits<CGameFont::String,CGameFont::String>::to_value_type_ptr
PUBLIC	?to_storage_type_ptr@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAPAUString@CGameFont@@PAU45@@Z ; stlp_std::priv::_CastTraits<CGameFont::String,CGameFont::String>::to_storage_type_ptr
PUBLIC	?erase@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@PAU34@0@Z ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::erase
PUBLIC	?clear_not_free@?$xr_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@@QAEXXZ ; xr_vector<CGameFont::String,xalloc<CGameFont::String> >::clear_not_free
PUBLIC	_ceilf
PUBLIC	?ceil@@YAMM@Z					; ceil
PUBLIC	?xr_realloc@@YAPAXPAXI@Z			; xr_realloc
PUBLIC	?set@?$_vector2@H@@QAEAAU1@MM@Z			; _vector2<int>::set
PUBLIC	?_M_throw_length_error@?$_Vector_base@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@IBEXXZ ; stlp_std::priv::_Vector_base<CGameFont::String,xalloc<CGameFont::String> >::_M_throw_length_error
PUBLIC	?max_size@?$xalloc@UString@CGameFont@@@@QBEIXZ	; xalloc<CGameFont::String>::max_size
PUBLIC	?max_size@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::max_size
PUBLIC	?_M_set@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@00@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_set
PUBLIC	?_Answer@?$_BothPtrType@PAUString@CGameFont@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<CGameFont::String *,CGameFont::String *>::_Answer
PUBLIC	??$__ucopy_ptrs@PAUString@CGameFont@@PAU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@00ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<CGameFont::String *,CGameFont::String *>
PUBLIC	??$__ucopy_aux@PAUString@CGameFont@@PAU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@00ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<CGameFont::String *,CGameFont::String *>
PUBLIC	??$uninitialized_copy@PAUString@CGameFont@@PAU12@@stlp_std@@YAPAUString@CGameFont@@PAU12@00@Z ; stlp_std::uninitialized_copy<CGameFont::String *,CGameFont::String *>
PUBLIC	??$_M_allocate_and_copy@PAUString@CGameFont@@@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEPAUString@CGameFont@@AAIPAU34@1@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_allocate_and_copy<CGameFont::String *>
PUBLIC	?reserve@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEXI@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::reserve
PUBLIC	?reserve@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEXI@Z ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::reserve
PUBLIC	??0?$xalloc@UString@CGameFont@@@@QAE@XZ		; xalloc<CGameFont::String>::xalloc<CGameFont::String>
PUBLIC	??0?$_Vector_base@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z ; stlp_std::priv::_Vector_base<CGameFont::String,xalloc<CGameFont::String> >::_Vector_base<CGameFont::String,xalloc<CGameFont::String> >
PUBLIC	??0?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >
PUBLIC	??0?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::vector<CGameFont::String,xalloc<CGameFont::String> >
PUBLIC	??0?$xr_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@@QAE@XZ ; xr_vector<CGameFont::String,xalloc<CGameFont::String> >::xr_vector<CGameFont::String,xalloc<CGameFont::String> >
PUBLIC	?IsNeedSpaceCharacter@@YAHG@Z			; IsNeedSpaceCharacter
PUBLIC	?IsBadStartCharacter@@YAHG@Z			; IsBadStartCharacter
PUBLIC	?IsBadEndCharacter@@YAHG@Z			; IsBadEndCharacter
PUBLIC	?g_current_font_scale@@3U?$_vector2@M@@A	; g_current_font_scale
PUBLIC	??_C@_0M@CLPDPKKE@font_prefix?$AA@		; `string'
PUBLIC	??_C@_0P@FPOFENP@ui_font_hud_01?$AA@		; `string'
PUBLIC	??_C@_0P@CONDAHBM@ui_font_hud_02?$AA@		; `string'
PUBLIC	??_C@_0BD@KJKHKIKC@ui_font_console_02?$AA@	; `string'
PUBLIC	??_C@_04PHHEBHMK@?4ini?$AA@			; `string'
PUBLIC	??_C@_0BG@MCALFBGP@CGameFont?3?3Initialize?$AA@	; `string'
PUBLIC	??_C@_0DB@CNKJHJKA@D?3?2CLEARSKY?2sources?2engine?2xrEng@ ; `string'
PUBLIC	??_C@_0CK@GCOGHIAJ@FS?4exist?$CIfn?0?$CC$game_textures$?$CC?0bu@ ; `string'
PUBLIC	??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@	; `string'
PUBLIC	??_C@_06LNLHEAAG@height?$AA@			; `string'
PUBLIC	??_C@_05MCHNBA@09608?$AA@			; `string'
PUBLIC	??_C@_04ODOGNJOP@?$CF05d?$AA@			; `string'
PUBLIC	??_C@_0O@PPLHMCEH@symbol_coords?$AA@		; `string'
PUBLIC	??_C@_04OHGLKFFN@?$CF03d?$AA@			; `string'
PUBLIC	??_C@_0M@OEPKPAIC@char?5widths?$AA@		; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_09NKHIABKK@font_size?$AA@			; `string'
PUBLIC	??_C@_0CA@POEFCMDI@ini?9?$DOsection_exist?$CI?$CCfont_size?$CC?$CJ?$AA@ ; `string'
PUBLIC	??_C@_05IGKADHGO@width?$AA@			; `string'
PUBLIC	??_C@_03GKJBDEPF@cpl?$AA@			; `string'
EXTRN	__imp__vsprintf_s:PROC
EXTRN	__imp__ceil:PROC
EXTRN	__imp_?mem_realloc@xrMemory@@QAEPAXPAXI@Z:PROC
EXTRN	__imp_?r_s32@CInifile@@QBEHPBD0@Z:PROC
;	COMDAT ?ignore_always@?8??Initialize@CGameFont@@QAEXPBD0@Z@4_NA
_BSS	SEGMENT
?ignore_always@?8??Initialize@CGameFont@@QAEXPBD0@Z@4_NA DB 01H DUP (?) ; `CGameFont::Initialize'::`9'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?CO@??Initialize@CGameFont@@QAEXPBD0@Z@4_NA
_BSS	SEGMENT
?ignore_always@?CO@??Initialize@CGameFont@@QAEXPBD0@Z@4_NA DB 01H DUP (?) ; `CGameFont::Initialize'::`46'::ignore_always
;	COMDAT ??_C@_03GKJBDEPF@cpl?$AA@
CONST	SEGMENT
??_C@_03GKJBDEPF@cpl?$AA@ DB 'cpl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGKADHGO@width?$AA@
CONST	SEGMENT
??_C@_05IGKADHGO@width?$AA@ DB 'width', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@POEFCMDI@ini?9?$DOsection_exist?$CI?$CCfont_size?$CC?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@POEFCMDI@ini?9?$DOsection_exist?$CI?$CCfont_size?$CC?$CJ?$AA@ DB 'i'
	DB	'ni->section_exist("font_size")', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NKHIABKK@font_size?$AA@
CONST	SEGMENT
??_C@_09NKHIABKK@font_size?$AA@ DB 'font_size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEPKPAIC@char?5widths?$AA@
CONST	SEGMENT
??_C@_0M@OEPKPAIC@char?5widths?$AA@ DB 'char widths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHGLKFFN@?$CF03d?$AA@
CONST	SEGMENT
??_C@_04OHGLKFFN@?$CF03d?$AA@ DB '%03d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PPLHMCEH@symbol_coords?$AA@
CONST	SEGMENT
??_C@_0O@PPLHMCEH@symbol_coords?$AA@ DB 'symbol_coords', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODOGNJOP@?$CF05d?$AA@
CONST	SEGMENT
??_C@_04ODOGNJOP@?$CF05d?$AA@ DB '%05d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MCHNBA@09608?$AA@
CONST	SEGMENT
??_C@_05MCHNBA@09608?$AA@ DB '09608', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNLHEAAG@height?$AA@
CONST	SEGMENT
??_C@_06LNLHEAAG@height?$AA@ DB 'height', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@
CONST	SEGMENT
??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@ DB 'mb_symbol_coords', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GCOGHIAJ@FS?4exist?$CIfn?0?$CC$game_textures$?$CC?0bu@
CONST	SEGMENT
??_C@_0CK@GCOGHIAJ@FS?4exist?$CIfn?0?$CC$game_textures$?$CC?0bu@ DB 'FS.e'
	DB	'xist(fn,"$game_textures$",buf,".ini")', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CNKJHJKA@D?3?2CLEARSKY?2sources?2engine?2xrEng@
CONST	SEGMENT
??_C@_0DB@CNKJHJKA@D?3?2CLEARSKY?2sources?2engine?2xrEng@ DB 'D:\CLEARSKY'
	DB	'\sources\engine\xrEngine\GameFont.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MCALFBGP@CGameFont?3?3Initialize?$AA@
CONST	SEGMENT
??_C@_0BG@MCALFBGP@CGameFont?3?3Initialize?$AA@ DB 'CGameFont::Initialize'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHHEBHMK@?4ini?$AA@
CONST	SEGMENT
??_C@_04PHHEBHMK@?4ini?$AA@ DB '.ini', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KJKHKIKC@ui_font_console_02?$AA@
CONST	SEGMENT
??_C@_0BD@KJKHKIKC@ui_font_console_02?$AA@ DB 'ui_font_console_02', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CONDAHBM@ui_font_hud_02?$AA@
CONST	SEGMENT
??_C@_0P@CONDAHBM@ui_font_hud_02?$AA@ DB 'ui_font_hud_02', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FPOFENP@ui_font_hud_01?$AA@
CONST	SEGMENT
??_C@_0P@FPOFENP@ui_font_hud_01?$AA@ DB 'ui_font_hud_01', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CLPDPKKE@font_prefix?$AA@
CONST	SEGMENT
??_C@_0M@CLPDPKKE@font_prefix?$AA@ DB 'font_prefix', 00H ; `string'
	ORG $+1
?g_current_font_scale@@3U?$_vector2@M@@A DD 03f800000r ; 1 ; g_current_font_scale
	DD	03f800000r			; 1
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
;	COMDAT ?xr_realloc@@YAPAXPAXI@Z
_TEXT	SEGMENT
?xr_realloc@@YAPAXPAXI@Z PROC				; xr_realloc, COMDAT
; _P$ = ecx
; _size$ = eax

; 113  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	push	eax
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_realloc@xrMemory@@QAEPAXPAXI@Z
	ret	0
?xr_realloc@@YAPAXPAXI@Z ENDP				; xr_realloc
; Function compile flags: /Ogtpy
; File j:\msvs8\vc\include\math.h
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT
__X$ = 8						; size = 4
_ceilf	PROC						; COMDAT

; 397  :         {return ((float)ceil((double)_X)); }

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
	add	esp, 8
	mov	esp, ebp
	pop	ebp
	ret	0
_ceilf	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?ceil@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?ceil@@YAMM@Z PROC					; ceil, COMDAT

; 502  :         {return (ceilf(_X)); }

	fld	DWORD PTR __X$[esp-4]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_ceilf
	add	esp, 4
	ret	0
?ceil@@YAMM@Z ENDP					; ceil
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\type_traits.h
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PAUString@CGameFont@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PAUString@CGameFont@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<CGameFont::String *,CGameFont::String *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PAUString@CGameFont@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<CGameFont::String *,CGameFont::String *>::_Answer
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__fill_n@PAUString@CGameFont@@IU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@IABU23@@Z
_TEXT	SEGMENT
??$__fill_n@PAUString@CGameFont@@IU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@IABU23@@Z PROC ; stlp_std::priv::__fill_n<CGameFont::String *,unsigned int,CGameFont::String>, COMDAT
; ___first$ = eax
; ___n$ = edx
; ___val$ = ebx

; 403  :   _STLP_FIX_LITERAL_BUG(__first)
; 404  :   for ( ; __n > 0; --__n, ++__first)

	test	edx, edx
	jbe	SHORT $LN1@fill_n@5
	push	esi
	push	edi
$LL3@fill_n@5:

; 405  :     *__first = __val;

	mov	edi, eax
	sub	edx, 1
	mov	ecx, 261				; 00000105H
	mov	esi, ebx
	add	eax, 1044				; 00000414H
	test	edx, edx
	rep movsd
	ja	SHORT $LL3@fill_n@5
	pop	edi
	pop	esi
$LN1@fill_n@5:

; 406  :   return __first;
; 407  : }

	ret	0
??$__fill_n@PAUString@CGameFont@@IU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@IABU23@@Z ENDP ; stlp_std::priv::__fill_n<CGameFont::String *,unsigned int,CGameFont::String>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?max_size@?$xalloc@UString@CGameFont@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@UString@CGameFont@@@@QBEIXZ PROC	; xalloc<CGameFont::String>::max_size, COMDAT

; 87   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 4113953				; 003ec621H
	ret	0
?max_size@?$xalloc@UString@CGameFont@@@@QBEIXZ ENDP	; xalloc<CGameFont::String>::max_size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_set@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@00@Z
_TEXT	SEGMENT
___e$ = 8						; size = 4
?_M_set@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@00@Z PROC ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_set, COMDAT
; _this$ = eax
; ___s$ = ecx
; ___f$ = edx

; 626  :     this->_M_start = __s;

	mov	DWORD PTR [eax], ecx

; 627  :     this->_M_finish = __f;
; 628  :     this->_M_end_of_storage._M_data = __e;

	mov	ecx, DWORD PTR ___e$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx

; 629  :   }

	ret	4
?_M_set@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@00@Z ENDP ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_set
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::max_size, COMDAT

; 182  :     size_type __vector_max_size = size_type(-1) / sizeof(_Tp);
; 183  :     typename allocator_type::size_type __alloc_max_size = this->_M_end_of_storage.max_size();
; 184  :     return (__alloc_max_size < __vector_max_size)?__alloc_max_size:__vector_max_size;

	mov	eax, 4113953				; 003ec621H

; 185  :   }

	ret	0
?max_size@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::max_size
; Function compile flags: /Ogtpy
; File j:\msvs8\vc\include\stdio.h
_TEXT	ENDS
;	COMDAT ??$vsprintf_s@$0EAA@@@YAHAAY0EAA@DPBDPAD@Z
_TEXT	SEGMENT
??$vsprintf_s@$0EAA@@@YAHAAY0EAA@DPBDPAD@Z PROC		; vsprintf_s<1024>, COMDAT
; __Dest$ = edx
; __Format$ = ecx
; __Args$ = eax

; 342  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vsprintf_s, __out_ecount(_Size) char, _Dest, __in_z __format_string const char *, _Format, va_list, _Args)

	push	eax
	push	ecx
	push	1024					; 00000400H
	push	edx
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	ret	0
??$vsprintf_s@$0EAA@@@YAHAAY0EAA@DPBDPAD@Z ENDP		; vsprintf_s<1024>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?to_storage_type_ptr@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAPAUString@CGameFont@@PAU45@@Z
_TEXT	SEGMENT
?to_storage_type_ptr@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAPAUString@CGameFont@@PAU45@@Z PROC ; stlp_std::priv::_CastTraits<CGameFont::String,CGameFont::String>::to_storage_type_ptr, COMDAT
; ___ptr$ = eax

; 248  :   { return __ptr; }

	ret	0
?to_storage_type_ptr@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAPAUString@CGameFont@@PAU45@@Z ENDP ; stlp_std::priv::_CastTraits<CGameFont::String,CGameFont::String>::to_storage_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAPAUString@CGameFont@@PAU45@@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAPAUString@CGameFont@@PAU45@@Z PROC ; stlp_std::priv::_CastTraits<CGameFont::String,CGameFont::String>::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 237  :   { return __ptr; }

	ret	0
?to_value_type_ptr@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAPAUString@CGameFont@@PAU45@@Z ENDP ; stlp_std::priv::_CastTraits<CGameFont::String,CGameFont::String>::to_value_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_storage_type_cref@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAABUString@CGameFont@@ABU45@@Z
_TEXT	SEGMENT
?to_storage_type_cref@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAABUString@CGameFont@@ABU45@@Z PROC ; stlp_std::priv::_CastTraits<CGameFont::String,CGameFont::String>::to_storage_type_cref, COMDAT
; ___ref$ = eax

; 254  :   { return __ref; }

	ret	0
?to_storage_type_cref@?$_CastTraits@UString@CGameFont@@U12@@priv@stlp_std@@SAABUString@CGameFont@@ABU45@@Z ENDP ; stlp_std::priv::_CastTraits<CGameFont::String,CGameFont::String>::to_storage_type_cref
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@UString@CGameFont@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@UString@CGameFont@@@@QAE@XZ PROC		; xalloc<CGameFont::String>::xalloc<CGameFont::String>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@UString@CGameFont@@@@QAE@XZ ENDP		; xalloc<CGameFont::String>::xalloc<CGameFont::String>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_vector2.h
_TEXT	ENDS
;	COMDAT ?set@?$_vector2@H@@QAEAAU1@MM@Z
_TEXT	SEGMENT
?set@?$_vector2@H@@QAEAAU1@MM@Z PROC			; _vector2<int>::set, COMDAT
; _this$ = eax

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax], 1
	mov	DWORD PTR [eax+4], 1
	ret	0
?set@?$_vector2@H@@QAEAAU1@MM@Z ENDP			; _vector2<int>::set
_TEXT	ENDS
PUBLIC	?SetHeight@CGameFont@@QAEXM@Z			; CGameFont::SetHeight
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\gamefont.cpp
;	COMDAT ?SetHeight@CGameFont@@QAEXM@Z
_TEXT	SEGMENT
_S$ = 8							; size = 4
?SetHeight@CGameFont@@QAEXM@Z PROC			; CGameFont::SetHeight, COMDAT
; _this$ = ecx

; 375  : 	VERIFY			( uFlags&fsDeviceIndependent );
; 376  : 	fCurrentHeight	= S;

	movss	xmm0, DWORD PTR _S$[esp-4]
	movss	DWORD PTR [ecx+24], xmm0

; 377  : };

	ret	4
?SetHeight@CGameFont@@QAEXM@Z ENDP			; CGameFont::SetHeight
_TEXT	ENDS
PUBLIC	?SetHeightI@CGameFont@@QAEXM@Z			; CGameFont::SetHeightI
; Function compile flags: /Ogtpy
;	COMDAT ?SetHeightI@CGameFont@@QAEXM@Z
_TEXT	SEGMENT
tv132 = -4						; size = 4
_S$ = 8							; size = 4
?SetHeightI@CGameFont@@QAEXM@Z PROC			; CGameFont::SetHeightI, COMDAT
; _this$ = ecx

; 368  : {

	push	ecx

; 369  : 	VERIFY			( uFlags&fsDeviceIndependent );
; 370  : 	fCurrentHeight	= S*RDEVICE.dwHeight;

	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+8
	fild	DWORD PTR ?Device@@3VCRenderDevice@@A+8
	test	eax, eax
	jge	SHORT $LN6@SetHeightI
	fadd	DWORD PTR __real@4f800000
$LN6@SetHeightI:
	fmul	DWORD PTR _S$[esp]
	fstp	DWORD PTR [ecx+24]

; 371  : };

	pop	ecx
	ret	4
?SetHeightI@CGameFont@@QAEXM@Z ENDP			; CGameFont::SetHeightI
_TEXT	ENDS
PUBLIC	?CurrentHeight_@CGameFont@@QAEMXZ		; CGameFont::CurrentHeight_
; Function compile flags: /Ogtpy
;	COMDAT ?CurrentHeight_@CGameFont@@QAEMXZ
_TEXT	SEGMENT
?CurrentHeight_@CGameFont@@QAEMXZ PROC			; CGameFont::CurrentHeight_, COMDAT
; _this$ = ecx

; 364  : 	return fCurrentHeight * vInterval.y;

	fld	DWORD PTR [ecx+40]
	fmul	DWORD PTR [ecx+24]

; 365  : }

	ret	0
?CurrentHeight_@CGameFont@@QAEMXZ ENDP			; CGameFont::CurrentHeight_
_TEXT	ENDS
PUBLIC	?OutSkip@CGameFont@@QAEXM@Z			; CGameFont::OutSkip
; Function compile flags: /Ogtpy
;	COMDAT ?OutSkip@CGameFont@@QAEXM@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?OutSkip@CGameFont@@QAEXM@Z PROC			; CGameFont::OutSkip, COMDAT
; _this$ = ecx

; 313  : 	fCurrentY += val*CurrentHeight_();

	movss	xmm0, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+24]
	mulss	xmm0, DWORD PTR _val$[esp-4]
	addss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR [ecx+32], xmm0

; 314  : }

	ret	4
?OutSkip@CGameFont@@QAEXM@Z ENDP			; CGameFont::OutSkip
_TEXT	ENDS
PUBLIC	?OutSet@CGameFont@@QAEXMM@Z			; CGameFont::OutSet
; Function compile flags: /Ogtpy
;	COMDAT ?OutSet@CGameFont@@QAEXMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?OutSet@CGameFont@@QAEXMM@Z PROC			; CGameFont::OutSet, COMDAT
; _this$ = ecx

; 177  : 	fCurrentX=x;

	movss	xmm0, DWORD PTR _x$[esp-4]
	movss	DWORD PTR [ecx+28], xmm0

; 178  : 	fCurrentY=y;

	movss	xmm0, DWORD PTR _y$[esp-4]
	movss	DWORD PTR [ecx+32], xmm0

; 179  : }

	ret	8
?OutSet@CGameFont@@QAEXMM@Z ENDP			; CGameFont::OutSet
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\mbhelpers.h
_TEXT	ENDS
;	COMDAT ?IsBadEndCharacter@@YAHG@Z
_TEXT	SEGMENT
?IsBadEndCharacter@@YAHG@Z PROC				; IsBadEndCharacter, COMDAT
; _wc$ = eax

; 53   : 	return ( 
; 54   : 		( wc == 0x0028 )  ||
; 55   : 
; 56   : 		( wc == 0xFF08 )  ||
; 57   : 
; 58   : 		( wc == 0x4E00 ) 
; 59   : 	);

	cmp	ax, 40					; 00000028H
	je	SHORT $LN3@IsBadEndCh
	cmp	ax, 65288				; 0000ff08H
	je	SHORT $LN3@IsBadEndCh
	cmp	ax, 19968				; 00004e00H
	je	SHORT $LN3@IsBadEndCh
	xor	eax, eax

; 60   : }

	ret	0
$LN3@IsBadEndCh:

; 53   : 	return ( 
; 54   : 		( wc == 0x0028 )  ||
; 55   : 
; 56   : 		( wc == 0xFF08 )  ||
; 57   : 
; 58   : 		( wc == 0x4E00 ) 
; 59   : 	);

	mov	eax, 1

; 60   : }

	ret	0
?IsBadEndCharacter@@YAHG@Z ENDP				; IsBadEndCharacter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsNeedSpaceCharacter@@YAHG@Z
_TEXT	SEGMENT
?IsNeedSpaceCharacter@@YAHG@Z PROC			; IsNeedSpaceCharacter, COMDAT
; _wc$ = eax

; 13   : 	return ( 
; 14   : 		( wc == 0x0020 )  ||
; 15   : 
; 16   : 		( wc == 0x3000 )  ||
; 17   : 
; 18   : 		( wc == 0xFF01 )  ||
; 19   : 		( wc == 0xFF0C )  ||
; 20   : //		( wc == 0xFF0D )  ||
; 21   : 		( wc == 0xFF0E )  ||
; 22   : 		( wc == 0xFF1A )  ||
; 23   : 		( wc == 0xFF1B )  ||
; 24   : 		( wc == 0xFF1F )  ||
; 25   : 
; 26   : 		( wc == 0x2026 )  ||
; 27   : 
; 28   : 		( wc == 0x3002 )  ||
; 29   : 		( wc == 0x3001 ) 
; 30   : 	);

	cmp	ax, 32					; 00000020H
	je	SHORT $LN3@IsNeedSpac
	cmp	ax, 12288				; 00003000H
	je	SHORT $LN3@IsNeedSpac
	cmp	ax, 65281				; 0000ff01H
	je	SHORT $LN3@IsNeedSpac
	cmp	ax, 65292				; 0000ff0cH
	je	SHORT $LN3@IsNeedSpac
	cmp	ax, 65294				; 0000ff0eH
	je	SHORT $LN3@IsNeedSpac
	cmp	ax, 65306				; 0000ff1aH
	je	SHORT $LN3@IsNeedSpac
	cmp	ax, 65307				; 0000ff1bH
	je	SHORT $LN3@IsNeedSpac
	cmp	ax, 65311				; 0000ff1fH
	je	SHORT $LN3@IsNeedSpac
	cmp	ax, 8230				; 00002026H
	je	SHORT $LN3@IsNeedSpac
	cmp	ax, 12290				; 00003002H
	je	SHORT $LN3@IsNeedSpac
	cmp	ax, 12289				; 00003001H
	je	SHORT $LN3@IsNeedSpac
	xor	eax, eax

; 31   : }

	ret	0
$LN3@IsNeedSpac:

; 13   : 	return ( 
; 14   : 		( wc == 0x0020 )  ||
; 15   : 
; 16   : 		( wc == 0x3000 )  ||
; 17   : 
; 18   : 		( wc == 0xFF01 )  ||
; 19   : 		( wc == 0xFF0C )  ||
; 20   : //		( wc == 0xFF0D )  ||
; 21   : 		( wc == 0xFF0E )  ||
; 22   : 		( wc == 0xFF1A )  ||
; 23   : 		( wc == 0xFF1B )  ||
; 24   : 		( wc == 0xFF1F )  ||
; 25   : 
; 26   : 		( wc == 0x2026 )  ||
; 27   : 
; 28   : 		( wc == 0x3002 )  ||
; 29   : 		( wc == 0x3001 ) 
; 30   : 	);

	mov	eax, 1

; 31   : }

	ret	0
?IsNeedSpaceCharacter@@YAHG@Z ENDP			; IsNeedSpaceCharacter
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
;	COMDAT ??$__ucopy_ptrs@PAUString@CGameFont@@PAU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@00ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PAUString@CGameFont@@PAU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@00ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<CGameFont::String *,CGameFont::String *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 117  :                                 const __true_type& /*TrivialUCopy*/) {

	push	esi
	mov	esi, edx

; 118  :   // we know they all pointers, so this cast is OK
; 119  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 120  :   return (_OutputIter)__ucopy_trivial(__first, __last, __result);

	cmp	esi, ecx
	je	SHORT $LN6@ucopy_ptrs@5
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@ucopy_ptrs@5:
	pop	esi

; 121  : }

	ret	0
??$__ucopy_ptrs@PAUString@CGameFont@@PAU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@00ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<CGameFont::String *,CGameFont::String *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__ucopy_aux@PAUString@CGameFont@@PAU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@00ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PAUString@CGameFont@@PAU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@00ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<CGameFont::String *,CGameFont::String *>, COMDAT
; ___first$ = edi
; ___last$ = eax
; ___result$ = ebx

; 125  :                                const __true_type& /*BothPtrType*/) {

	push	esi

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	push	0
	push	0
	mov	esi, eax
	call	??$_UseTrivialUCopy@UString@CGameFont@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UString@CGameFont@@U12@@0@PAUString@CGameFont@@0@Z ; stlp_std::_UseTrivialUCopy<CGameFont::String,CGameFont::String>
	add	esp, 8
	call	?_Answer@?$_TrivialUCopy@UString@CGameFont@@U12@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<CGameFont::String,CGameFont::String>::_Answer
	cmp	esi, edi
	jne	SHORT $LN11@ucopy_aux
	mov	eax, ebx
	pop	esi

; 129  : }

	ret	0

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

$LN11@ucopy_aux:
	sub	esi, edi
	push	esi
	push	edi
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi

; 129  : }

	ret	0
??$__ucopy_aux@PAUString@CGameFont@@PAU12@@priv@stlp_std@@YAPAUString@CGameFont@@PAU23@00ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<CGameFont::String *,CGameFont::String *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PAUString@CGameFont@@PAU12@@stlp_std@@YAPAUString@CGameFont@@PAU12@00@Z
_TEXT	SEGMENT
??$uninitialized_copy@PAUString@CGameFont@@PAU12@@stlp_std@@YAPAUString@CGameFont@@PAU12@00@Z PROC ; stlp_std::uninitialized_copy<CGameFont::String *,CGameFont::String *>, COMDAT
; ___first$ = edi
; ___last$ = eax
; ___result$ = ebx

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	push	esi
	push	0
	push	0
	mov	esi, eax
	call	??$_UseTrivialUCopy@UString@CGameFont@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UString@CGameFont@@U12@@0@PAUString@CGameFont@@0@Z ; stlp_std::_UseTrivialUCopy<CGameFont::String,CGameFont::String>
	add	esp, 8
	call	?_Answer@?$_TrivialUCopy@UString@CGameFont@@U12@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<CGameFont::String,CGameFont::String>::_Answer
	cmp	esi, edi
	jne	SHORT $LN15@uninitiali@2
	mov	eax, ebx
	pop	esi
	ret	0
$LN15@uninitiali@2:
	sub	esi, edi
	push	esi
	push	edi
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi
	ret	0
??$uninitialized_copy@PAUString@CGameFont@@PAU12@@stlp_std@@YAPAUString@CGameFont@@PAU12@00@Z ENDP ; stlp_std::uninitialized_copy<CGameFont::String *,CGameFont::String *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PAUString@CGameFont@@@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEPAUString@CGameFont@@AAIPAU34@1@Z
_TEXT	SEGMENT
___last$ = 8						; size = 4
??$_M_allocate_and_copy@PAUString@CGameFont@@@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEPAUString@CGameFont@@AAIPAU34@1@Z PROC ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_allocate_and_copy<CGameFont::String *>, COMDAT
; _this$ = ecx
; ___n$ = eax
; ___first$ = ebx

; 633  :   pointer _M_allocate_and_copy(size_type& __n,

	push	esi
	mov	esi, DWORD PTR ___last$[esp]
	push	edi

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	push	eax
	mov	eax, DWORD PTR [eax]
	push	eax
	add	ecx, 8
	call	?allocate@?$_STLP_alloc_proxy@PAUString@CGameFont@@U12@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >::allocate

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	push	0
	push	0
	mov	edi, eax
	call	??$_UseTrivialUCopy@UString@CGameFont@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UString@CGameFont@@U12@@0@PAUString@CGameFont@@0@Z ; stlp_std::_UseTrivialUCopy<CGameFont::String,CGameFont::String>
	add	esp, 8
	call	?_Answer@?$_TrivialUCopy@UString@CGameFont@@U12@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<CGameFont::String,CGameFont::String>::_Answer
	cmp	esi, ebx
	je	SHORT $LN29@M_allocate
	sub	esi, ebx
	push	esi
	push	ebx
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN29@M_allocate:

; 643  :       return __result;

	mov	eax, edi
	pop	edi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	4
??$_M_allocate_and_copy@PAUString@CGameFont@@@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEPAUString@CGameFont@@AAIPAU34@1@Z ENDP ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_allocate_and_copy<CGameFont::String *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_Vector_base@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@IBEXXZ
_TEXT	SEGMENT
?_M_throw_length_error@?$_Vector_base@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@IBEXXZ PROC ; stlp_std::priv::_Vector_base<CGameFont::String,xalloc<CGameFont::String> >::_M_throw_length_error, COMDAT

; 41   :   __stl_throw_length_error("vector");

	push	OFFSET ??_C@_06NBFPPGEG@vector?$AA@
	call	DWORD PTR __imp__puts
	add	esp, 4
	jmp	DWORD PTR __imp__abort
?_M_throw_length_error@?$_Vector_base@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@IBEXXZ ENDP ; stlp_std::priv::_Vector_base<CGameFont::String,xalloc<CGameFont::String> >::_M_throw_length_error
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Copy_Construct@UString@CGameFont@@@stlp_std@@YAXPAUString@CGameFont@@ABU12@@Z
_TEXT	SEGMENT
??$_Copy_Construct@UString@CGameFont@@@stlp_std@@YAXPAUString@CGameFont@@ABU12@@Z PROC ; stlp_std::_Copy_Construct<CGameFont::String>, COMDAT
; ___p$ = eax
; ___val$ = edx

; 109  : inline void _Copy_Construct(_Tp* __p, const _Tp& __val) {

	push	edi
	mov	edi, eax

; 110  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 111  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_Tp));
; 112  : #endif
; 113  :   _STLP_PLACEMENT_NEW (__p) _Tp(__val);

	test	edi, edi
	je	SHORT $LN3@Copy_Const@6
	push	esi
	mov	ecx, 261				; 00000105H
	mov	esi, edx
	rep movsd
	pop	esi
$LN3@Copy_Const@6:
	pop	edi

; 114  : }

	ret	0
??$_Copy_Construct@UString@CGameFont@@@stlp_std@@YAXPAUString@CGameFont@@ABU12@@Z ENDP ; stlp_std::_Copy_Construct<CGameFont::String>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?end@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@XZ
_TEXT	SEGMENT
?end@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@XZ PROC ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::end, COMDAT
; _this$ = ecx

; 81   :   iterator end()               { return cast_traits::to_value_type_ptr(_M_impl.end()); }

	jmp	?end@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@XZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::end
?end@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@XZ ENDP ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@XZ
_TEXT	SEGMENT
?begin@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@XZ PROC ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::begin, COMDAT
; _this$ = ecx

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	jmp	?begin@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@XZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::begin
?begin@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@XZ ENDP ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::begin
_TEXT	ENDS
PUBLIC	?SizeOf_@CGameFont@@QAEMPBG@Z			; CGameFont::SizeOf_
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\gamefont.cpp
;	COMDAT ?SizeOf_@CGameFont@@QAEMPBG@Z
_TEXT	SEGMENT
_X$ = 8							; size = 4
_wsStr$ = 8						; size = 4
?SizeOf_@CGameFont@@QAEMPBG@Z PROC			; CGameFont::SizeOf_, COMDAT
; _this$ = ecx

; 344  : {

	push	ebx

; 345  : 	if ( ! ( wsStr && wsStr[ 0 ] ) )

	mov	ebx, DWORD PTR _wsStr$[esp]
	test	ebx, ebx
	je	$LN6@SizeOf_
	movzx	eax, WORD PTR [ebx]
	test	ax, ax
	je	$LN6@SizeOf_

; 347  : 
; 348  : 	unsigned int len = wsStr[ 0 ];
; 349  : 	float X	= 0.0f , fDelta = 0.0f;

	xorps	xmm1, xmm1
	push	ebp
	movzx	ebp, ax

; 350  : 
; 351  : 	if ( len )

	test	ebp, ebp
	movss	DWORD PTR _X$[esp+4], xmm1
	je	$LN2@SizeOf_
	push	esi

; 352  : 		for ( unsigned int j=1 ; j <= len ; j++ ) {

	mov	esi, 1
	cmp	ebp, esi
	jb	$LN19@SizeOf_
	movss	xmm2, DWORD PTR __real@40000000
	push	edi
	mov	edi, DWORD PTR [ecx+44]
	npad	8
$LL4@SizeOf_:

; 353  : 			fDelta = GetCharTC( wsStr[ j ] ).z - 2;

	movzx	eax, WORD PTR [ebx+esi*2]
	movzx	edx, ax

; 354  : 			if ( IsNeedSpaceCharacter( wsStr[ j ] ) )

	movzx	eax, ax
	cmp	ax, 32					; 00000020H
	lea	edx, DWORD PTR [edx+edx*2]
	movss	xmm0, DWORD PTR [edi+edx*4+8]
	subss	xmm0, xmm2
	je	SHORT $LN14@SizeOf_
	cmp	ax, 12288				; 00003000H
	je	SHORT $LN14@SizeOf_
	cmp	ax, 65281				; 0000ff01H
	je	SHORT $LN14@SizeOf_
	cmp	ax, 65292				; 0000ff0cH
	je	SHORT $LN14@SizeOf_
	cmp	ax, 65294				; 0000ff0eH
	je	SHORT $LN14@SizeOf_
	cmp	ax, 65306				; 0000ff1aH
	je	SHORT $LN14@SizeOf_
	cmp	ax, 65307				; 0000ff1bH
	je	SHORT $LN14@SizeOf_
	cmp	ax, 65311				; 0000ff1fH
	je	SHORT $LN14@SizeOf_
	cmp	ax, 8230				; 00002026H
	je	SHORT $LN14@SizeOf_
	cmp	ax, 12290				; 00003002H
	je	SHORT $LN14@SizeOf_
	cmp	ax, 12289				; 00003001H
	jne	SHORT $LN1@SizeOf_
$LN14@SizeOf_:

; 355  : 				fDelta += fXStep;

	movss	xmm3, DWORD PTR [ecx+52]
	addss	xmm3, xmm0
	movaps	xmm0, xmm3
$LN1@SizeOf_:
	add	esi, 1
	cmp	esi, ebp

; 356  : 			X += fDelta;

	addss	xmm0, xmm1
	movaps	xmm1, xmm0
	jbe	SHORT $LL4@SizeOf_
	movss	DWORD PTR _X$[esp+12], xmm1
	pop	edi
$LN19@SizeOf_:
	pop	esi
$LN2@SizeOf_:

; 357  : 		}
; 358  : 
; 359  : 	return ( X * vInterval.x );

	fld	DWORD PTR [ecx+36]
	pop	ebp
	fmul	DWORD PTR _X$[esp]
	pop	ebx

; 360  : }

	ret	4
$LN6@SizeOf_:

; 346  : 		return 0;

	fldz
	pop	ebx

; 360  : }

	ret	4
?SizeOf_@CGameFont@@QAEMPBG@Z ENDP			; CGameFont::SizeOf_
_TEXT	ENDS
PUBLIC	?SizeOf_@CGameFont@@QAEMPBD@Z			; CGameFont::SizeOf_
; Function compile flags: /Ogtpy
;	COMDAT ?SizeOf_@CGameFont@@QAEMPBD@Z
_TEXT	SEGMENT
_X$ = -8196						; size = 4
_wsStr$116996 = -8192					; size = 8192
_s$ = 8							; size = 4
?SizeOf_@CGameFont@@QAEMPBD@Z PROC			; CGameFont::SizeOf_, COMDAT
; _this$ = ecx

; 322  : {

	mov	eax, 8196				; 00002004H
	call	__chkstk
	push	ebp
	mov	ebp, ecx

; 323  : 	if ( ! ( s && s[ 0 ] ) )

	mov	ecx, DWORD PTR _s$[esp+8196]
	test	ecx, ecx
	je	$LN6@SizeOf_@2
	cmp	BYTE PTR [ecx], 0
	je	$LN6@SizeOf_@2

; 325  : 
; 326  : 	if ( IsMultibyte() ) {

	test	BYTE PTR [ebp+84], 8
	je	SHORT $LN5@SizeOf_@2

; 327  : 		wide_char wsStr[ MAX_MB_CHARS ];
; 328  : 
; 329  : 		mbhMulti2Wide( wsStr , NULL , MAX_MB_CHARS , s );

	push	ecx
	push	4096					; 00001000H
	lea	eax, DWORD PTR _wsStr$116996[esp+8208]
	push	0
	push	eax
	call	?mbhMulti2Wide@@YAGPAG0GPBD@Z		; mbhMulti2Wide
	add	esp, 16					; 00000010H

; 330  : 
; 331  : 		return SizeOf_( wsStr );

	lea	ecx, DWORD PTR _wsStr$116996[esp+8200]
	push	ecx
	mov	ecx, ebp
	call	?SizeOf_@CGameFont@@QAEMPBG@Z		; CGameFont::SizeOf_
	pop	ebp

; 341  : }

	add	esp, 8196				; 00002004H
	ret	4
$LN5@SizeOf_@2:
	push	ebx

; 332  : 	}
; 333  : 
; 334  : 	int		len			= xr_strlen(s);

	mov	eax, ecx
	push	esi
	lea	esi, DWORD PTR [eax+1]
	npad	3
$LL21@SizeOf_@2:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL21@SizeOf_@2

; 335  : 	float	X			= 0;

	xorps	xmm0, xmm0
	sub	eax, esi
	mov	ebx, eax
	movss	DWORD PTR _X$[esp+8208], xmm0

; 336  : 	if (len)

	je	$LN18@SizeOf_@2

; 337  : 		for (int j=0; j<len; j++)

	xor	eax, eax
	cmp	ebx, 4
	jl	SHORT $LC19@SizeOf_@2
	mov	edx, DWORD PTR [ebp+44]
	push	edi
	lea	edi, DWORD PTR [ebx-3]
	npad	6
$LL20@SizeOf_@2:

; 338  : 			X			+= GetCharTC( ( u16 ) ( u8 ) s[ j ] ).z;

	movzx	esi, BYTE PTR [ecx+eax]
	lea	esi, DWORD PTR [esi+esi*2]
	movss	xmm1, DWORD PTR [edx+esi*4+8]
	movzx	esi, BYTE PTR [ecx+eax+1]
	lea	esi, DWORD PTR [esi+esi*2]
	addss	xmm1, xmm0
	addss	xmm1, DWORD PTR [edx+esi*4+8]
	movzx	esi, BYTE PTR [ecx+eax+2]
	lea	esi, DWORD PTR [esi+esi*2]
	addss	xmm1, DWORD PTR [edx+esi*4+8]
	movzx	esi, BYTE PTR [ecx+eax+3]
	lea	esi, DWORD PTR [esi+esi*2]
	addss	xmm1, DWORD PTR [edx+esi*4+8]
	add	eax, 4
	cmp	eax, edi
	movaps	xmm0, xmm1
	jl	SHORT $LL20@SizeOf_@2
	movss	DWORD PTR _X$[esp+8212], xmm0
	pop	edi
$LC19@SizeOf_@2:

; 337  : 		for (int j=0; j<len; j++)

	cmp	eax, ebx
	jge	SHORT $LN18@SizeOf_@2
	mov	esi, DWORD PTR [ebp+44]
$LC3@SizeOf_@2:

; 338  : 			X			+= GetCharTC( ( u16 ) ( u8 ) s[ j ] ).z;

	movzx	edx, BYTE PTR [eax+ecx]
	lea	edx, DWORD PTR [edx+edx*2]
	movss	xmm1, DWORD PTR [esi+edx*4+8]
	add	eax, 1
	cmp	eax, ebx
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	jl	SHORT $LC3@SizeOf_@2
	movss	DWORD PTR _X$[esp+8208], xmm0
$LN18@SizeOf_@2:

; 339  : 
; 340  : 	return				(X*vInterval.x);

	fld	DWORD PTR [ebp+36]
	pop	esi
	fmul	DWORD PTR _X$[esp+8204]
	pop	ebx
	pop	ebp

; 341  : }

	add	esp, 8196				; 00002004H
	ret	4
$LN6@SizeOf_@2:

; 324  : 		return 0;

	fldz
	pop	ebp

; 341  : }

	add	esp, 8196				; 00002004H
	ret	4
?SizeOf_@CGameFont@@QAEMPBD@Z ENDP			; CGameFont::SizeOf_
_TEXT	ENDS
PUBLIC	?SizeOf_@CGameFont@@QAEMD@Z			; CGameFont::SizeOf_
; Function compile flags: /Ogtpy
;	COMDAT ?SizeOf_@CGameFont@@QAEMD@Z
_TEXT	SEGMENT
_cChar$ = 8						; size = 1
?SizeOf_@CGameFont@@QAEMD@Z PROC			; CGameFont::SizeOf_, COMDAT
; _this$ = ecx

; 318  : 	return ( GetCharTC( ( u16 ) ( u8 ) ( ( ( IsMultibyte() && cChar == ' ' ) ) ? 0 : cChar) ).z * vInterval.x );

	test	BYTE PTR [ecx+84], 8
	mov	al, BYTE PTR _cChar$[esp-4]
	je	SHORT $LN3@SizeOf_@3
	cmp	al, 32					; 00000020H
	jne	SHORT $LN3@SizeOf_@3
	mov	edx, DWORD PTR [ecx+44]
	xor	eax, eax
	movzx	eax, al
	lea	eax, DWORD PTR [eax+eax*2]
	fld	DWORD PTR [edx+eax*4+8]
	fmul	DWORD PTR [ecx+36]

; 319  : }

	ret	4
$LN3@SizeOf_@3:

; 318  : 	return ( GetCharTC( ( u16 ) ( u8 ) ( ( ( IsMultibyte() && cChar == ' ' ) ) ? 0 : cChar) ).z * vInterval.x );

	mov	edx, DWORD PTR [ecx+44]
	movsx	eax, al
	movzx	eax, al
	lea	eax, DWORD PTR [eax+eax*2]
	fld	DWORD PTR [edx+eax*4+8]
	fmul	DWORD PTR [ecx+36]

; 319  : }

	ret	4
?SizeOf_@CGameFont@@QAEMD@Z ENDP			; CGameFont::SizeOf_
_TEXT	ENDS
PUBLIC	?GetCutLengthPos@CGameFont@@QAEGMPBD@Z		; CGameFont::GetCutLengthPos
; Function compile flags: /Ogtpy
;	COMDAT ?GetCutLengthPos@CGameFont@@QAEGMPBD@Z
_TEXT	SEGMENT
_wsPos$ = -16384					; size = 8224
_wsStr$ = -8192						; size = 8192
_fTargetWidth$ = 8					; size = 4
_pszText$ = 12						; size = 4
?GetCutLengthPos@CGameFont@@QAEGMPBD@Z PROC		; CGameFont::GetCutLengthPos, COMDAT
; _this$ = ecx

; 198  : {

	mov	eax, 16384				; 00004000H
	call	__chkstk

; 199  : 	VERIFY( pszText );
; 200  : 
; 201  : 	wide_char wsStr[ MAX_MB_CHARS ], wsPos[ MAX_MB_CHARS ];
; 202  : 	float fCurWidth = 0.0f , fDelta = 0.0f;
; 203  : 
; 204  : 	u16	len	= mbhMulti2Wide( wsStr , wsPos , MAX_MB_CHARS , pszText );

	mov	eax, DWORD PTR _pszText$[esp+16380]
	xorps	xmm1, xmm1
	push	ebx
	push	edi
	push	eax
	mov	ebx, ecx
	push	4096					; 00001000H
	lea	ecx, DWORD PTR _wsPos$[esp+16400]
	push	ecx
	lea	edx, DWORD PTR _wsStr$[esp+16404]
	push	edx
	call	?mbhMulti2Wide@@YAGPAG0GPBD@Z		; mbhMulti2Wide
	movzx	edi, ax

; 205  : 
; 206  : 	for ( u16 i = 1 ; i <= len ; i++ ) {

	mov	edx, 1
	add	esp, 16					; 00000010H
	cmp	di, dx
	jb	$LN23@GetCutLeng
	movss	xmm2, DWORD PTR _fTargetWidth$[esp+16388]
	movss	xmm3, DWORD PTR __real@40000000
	push	esi
	mov	esi, DWORD PTR [ebx+44]
	npad	7
$LL6@GetCutLeng:

; 207  : 
; 208  : 		fDelta = GetCharTC( wsStr[ i ] ).z - 2;

	movzx	eax, dx
	movzx	eax, WORD PTR _wsStr$[esp+eax*2+16396]
	movzx	ecx, ax

; 209  : 
; 210  : 		if ( IsNeedSpaceCharacter( wsStr[ i ] ) )

	movzx	eax, ax
	cmp	ax, 32					; 00000020H
	lea	ecx, DWORD PTR [ecx+ecx*2]
	movss	xmm0, DWORD PTR [esi+ecx*4+8]
	subss	xmm0, xmm3
	je	SHORT $LN16@GetCutLeng
	cmp	ax, 12288				; 00003000H
	je	SHORT $LN16@GetCutLeng
	cmp	ax, 65281				; 0000ff01H
	je	SHORT $LN16@GetCutLeng
	cmp	ax, 65292				; 0000ff0cH
	je	SHORT $LN16@GetCutLeng
	cmp	ax, 65294				; 0000ff0eH
	je	SHORT $LN16@GetCutLeng
	cmp	ax, 65306				; 0000ff1aH
	je	SHORT $LN16@GetCutLeng
	cmp	ax, 65307				; 0000ff1bH
	je	SHORT $LN16@GetCutLeng
	cmp	ax, 65311				; 0000ff1fH
	je	SHORT $LN16@GetCutLeng
	cmp	ax, 8230				; 00002026H
	je	SHORT $LN16@GetCutLeng
	cmp	ax, 12290				; 00003002H
	je	SHORT $LN16@GetCutLeng
	cmp	ax, 12289				; 00003001H
	jne	SHORT $LN3@GetCutLeng
$LN16@GetCutLeng:

; 211  : 			fDelta += fXStep;

	movss	xmm4, DWORD PTR [ebx+52]
	addss	xmm4, xmm0
	movaps	xmm0, xmm4
$LN3@GetCutLeng:

; 212  : 
; 213  : 		if ( ( fCurWidth + fDelta ) > fTargetWidth )

	addss	xmm0, xmm1
	comiss	xmm0, xmm2
	ja	SHORT $LN22@GetCutLeng
	add	edx, 1
	cmp	dx, di

; 214  : 			break;
; 215  : 		else 
; 216  : 			fCurWidth += fDelta;

	movaps	xmm1, xmm0
	jbe	SHORT $LL6@GetCutLeng
	pop	esi

; 217  : 	}
; 218  : 
; 219  : 	return wsPos[ i - 1 ];

	movzx	edx, dx
	mov	ax, WORD PTR _wsPos$[esp+edx*2+16390]
	pop	edi
	pop	ebx

; 220  : }

	add	esp, 16384				; 00004000H
	ret	8
$LN22@GetCutLeng:
	pop	esi

; 217  : 	}
; 218  : 
; 219  : 	return wsPos[ i - 1 ];

	movzx	eax, dx
	mov	ax, WORD PTR _wsPos$[esp+eax*2+16390]
	pop	edi
	pop	ebx

; 220  : }

	add	esp, 16384				; 00004000H
	ret	8
$LN23@GetCutLeng:

; 217  : 	}
; 218  : 
; 219  : 	return wsPos[ i - 1 ];

	movzx	ecx, dx
	mov	ax, WORD PTR _wsPos$[esp+ecx*2+16390]
	pop	edi
	pop	ebx

; 220  : }

	add	esp, 16384				; 00004000H
	ret	8
?GetCutLengthPos@CGameFont@@QAEGMPBD@Z ENDP		; CGameFont::GetCutLengthPos
_TEXT	ENDS
PUBLIC	?smart_strlen@CGameFont@@QAEIPBD@Z		; CGameFont::smart_strlen
; Function compile flags: /Ogtpy
;	COMDAT ?smart_strlen@CGameFont@@QAEIPBD@Z
_TEXT	SEGMENT
_S$ = 8							; size = 4
?smart_strlen@CGameFont@@QAEIPBD@Z PROC			; CGameFont::smart_strlen, COMDAT
; _this$ = ecx

; 188  : 	return ( IsMultibyte() ? mbhMulti2Wide( NULL , NULL , 0 , S ) : xr_strlen( S ) );

	test	BYTE PTR [ecx+84], 8
	mov	eax, DWORD PTR _S$[esp-4]
	je	SHORT $LN3@smart_strl
	push	eax
	push	0
	push	0
	push	0
	call	?mbhMulti2Wide@@YAGPAG0GPBD@Z		; mbhMulti2Wide
	add	esp, 16					; 00000010H
	movzx	eax, ax

; 189  : }

	ret	4
$LN3@smart_strl:

; 188  : 	return ( IsMultibyte() ? mbhMulti2Wide( NULL , NULL , 0 , S ) : xr_strlen( S ) );

	lea	edx, DWORD PTR [eax+1]
$LL9@smart_strl:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL9@smart_strl
	sub	eax, edx

; 189  : }

	ret	4
?smart_strlen@CGameFont@@QAEIPBD@Z ENDP			; CGameFont::smart_strlen
_TEXT	ENDS
PUBLIC	?OutSetI@CGameFont@@QAEXMM@Z			; CGameFont::OutSetI
; Function compile flags: /Ogtpy
;	COMDAT ?OutSetI@CGameFont@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv298 = -4						; size = 4
tv284 = -4						; size = 4
_a$239869 = 8						; size = 4
_x$ = 8							; size = 4
_a$239861 = 12						; size = 4
_y$ = 12						; size = 4
?OutSetI@CGameFont@@QAEXMM@Z PROC			; CGameFont::OutSetI, COMDAT
; _this$ = ecx

; 182  : {

	sub	esp, 8

; 183  : 	OutSet(DI2PX(x),DI2PY(y));

	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	push	ebx
	push	ebp
	mov	DWORD PTR _this$[esp+16], ecx
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+60]
	push	esi
	push	edi
	call	eax
	mov	ecx, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	esi, eax
	mov	eax, DWORD PTR [edx+60]
	call	eax
	mov	edx, DWORD PTR [esi]
	mov	ebp, eax
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, esi
	call	eax
	test	eax, eax
	mov	DWORD PTR tv298[esp+24], eax
	fild	DWORD PTR tv298[esp+24]
	jge	SHORT $LN9@OutSetI
	fadd	DWORD PTR __real@4f800000
$LN9@OutSetI:
	fld	DWORD PTR _y$[esp+20]
	mov	edx, DWORD PTR [ebp]
	fadd	DWORD PTR __real@3f800000
	mov	ebx, 158				; 0000009eH
	mov	esi, 1
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@3f000000
	fstp	DWORD PTR _a$239861[esp+20]
	mov	eax, DWORD PTR _a$239861[esp+20]
	mov	ecx, eax
	sar	ecx, 23					; 00000017H
	and	ecx, 255				; 000000ffH
	sub	ebx, ecx
	mov	edi, eax
	or	edi, -8388608				; ff800000H
	shl	edi, 8
	mov	ecx, ebx
	shr	edi, cl
	sub	ebx, 96					; 00000060H
	mov	ecx, ebx
	shl	esi, cl
	mov	ecx, ebp
	sub	esi, 1
	sar	esi, 8
	and	esi, eax
	neg	esi
	sbb	esi, esi
	sar	eax, 31					; 0000001fH
	mov	DWORD PTR _a$239861[esp+20], eax
	mov	eax, DWORD PTR [edx+40]
	add	esi, 1
	call	eax
	test	eax, eax
	mov	DWORD PTR tv284[esp+24], eax
	fild	DWORD PTR tv284[esp+24]
	jge	SHORT $LN10@OutSetI
	fadd	DWORD PTR __real@4f800000
$LN10@OutSetI:
	fld	DWORD PTR _x$[esp+20]
	mov	ecx, 158				; 0000009eH
	fadd	DWORD PTR __real@3f800000
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@3f000000
	fstp	DWORD PTR _a$239869[esp+20]
	mov	edx, DWORD PTR _a$239869[esp+20]
	mov	ebp, DWORD PTR _a$239869[esp+20]
	mov	eax, edx
	sar	eax, 23					; 00000017H
	and	eax, 255				; 000000ffH
	sub	ecx, eax
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	mov	eax, 1
	shl	eax, cl
	sub	eax, 1
	sar	eax, 8
	and	eax, ebp
	neg	eax
	sbb	eax, eax
	sar	ebp, 31					; 0000001fH
	add	eax, 1
	and	eax, ebp
	add	ecx, 64					; 00000040H
	sub	edx, eax
	mov	eax, DWORD PTR _this$[esp+24]
	sar	ecx, 31					; 0000001fH
	and	edx, ecx
	mov	ecx, DWORD PTR _a$239861[esp+20]
	and	esi, ecx
	add	ebx, 64					; 00000040H
	sub	edi, esi
	sar	ebx, 31					; 0000001fH
	xor	edx, ebp
	and	edi, ebx
	cvtsi2ss xmm0, edx
	xor	edi, ecx
	movss	DWORD PTR [eax+28], xmm0
	cvtsi2ss xmm0, edi
	pop	edi
	pop	esi
	pop	ebp
	movss	DWORD PTR [eax+32], xmm0
	pop	ebx

; 184  : }

	add	esp, 8
	ret	8
?OutSetI@CGameFont@@QAEXMM@Z ENDP			; CGameFont::OutSetI
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\mbhelpers.h
_TEXT	ENDS
;	COMDAT ?IsBadStartCharacter@@YAHG@Z
_TEXT	SEGMENT
?IsBadStartCharacter@@YAHG@Z PROC			; IsBadStartCharacter, COMDAT
; _wc$ = eax

; 35   : 	return ( 
; 36   : 		IsNeedSpaceCharacter( wc ) ||
; 37   : 
; 38   : 		( wc == 0x0021 )  ||
; 39   : 		( wc == 0x002C )  ||
; 40   : //		( wc == 0x002D )  ||
; 41   : 		( wc == 0x002E )  ||
; 42   : 		( wc == 0x003A )  ||
; 43   : 		( wc == 0x003B )  ||
; 44   : 		( wc == 0x003F )  ||
; 45   : 
; 46   : 		( wc == 0x0029 )  ||
; 47   : 		( wc == 0xFF09 )
; 48   : 	);

	cmp	ax, 32					; 00000020H
	je	SHORT $LN3@IsBadStart
	cmp	ax, 12288				; 00003000H
	je	SHORT $LN3@IsBadStart
	cmp	ax, 65281				; 0000ff01H
	je	SHORT $LN3@IsBadStart
	cmp	ax, 65292				; 0000ff0cH
	je	SHORT $LN3@IsBadStart
	cmp	ax, 65294				; 0000ff0eH
	je	SHORT $LN3@IsBadStart
	cmp	ax, 65306				; 0000ff1aH
	je	SHORT $LN3@IsBadStart
	cmp	ax, 65307				; 0000ff1bH
	je	SHORT $LN3@IsBadStart
	cmp	ax, 65311				; 0000ff1fH
	je	SHORT $LN3@IsBadStart
	cmp	ax, 8230				; 00002026H
	je	SHORT $LN3@IsBadStart
	cmp	ax, 12290				; 00003002H
	je	SHORT $LN3@IsBadStart
	cmp	ax, 12289				; 00003001H
	je	SHORT $LN3@IsBadStart
	cmp	ax, 33					; 00000021H
	je	SHORT $LN3@IsBadStart
	cmp	ax, 44					; 0000002cH
	je	SHORT $LN3@IsBadStart
	cmp	ax, 46					; 0000002eH
	je	SHORT $LN3@IsBadStart
	cmp	ax, 58					; 0000003aH
	je	SHORT $LN3@IsBadStart
	cmp	ax, 59					; 0000003bH
	je	SHORT $LN3@IsBadStart
	cmp	ax, 63					; 0000003fH
	je	SHORT $LN3@IsBadStart
	cmp	ax, 41					; 00000029H
	je	SHORT $LN3@IsBadStart
	cmp	ax, 65289				; 0000ff09H
	je	SHORT $LN3@IsBadStart
	xor	eax, eax

; 49   : }

	ret	0
$LN3@IsBadStart:

; 35   : 	return ( 
; 36   : 		IsNeedSpaceCharacter( wc ) ||
; 37   : 
; 38   : 		( wc == 0x0021 )  ||
; 39   : 		( wc == 0x002C )  ||
; 40   : //		( wc == 0x002D )  ||
; 41   : 		( wc == 0x002E )  ||
; 42   : 		( wc == 0x003A )  ||
; 43   : 		( wc == 0x003B )  ||
; 44   : 		( wc == 0x003F )  ||
; 45   : 
; 46   : 		( wc == 0x0029 )  ||
; 47   : 		( wc == 0xFF09 )
; 48   : 	);

	mov	eax, 1

; 49   : }

	ret	0
?IsBadStartCharacter@@YAHG@Z ENDP			; IsBadStartCharacter
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
;	COMDAT ??0?$_Vector_base@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z PROC ; stlp_std::priv::_Vector_base<CGameFont::String,xalloc<CGameFont::String> >::_Vector_base<CGameFont::String,xalloc<CGameFont::String> >, COMDAT
; _this$ = esi
; ___a$ = eax

; 67   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

	push	0
	push	eax
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	call	??0?$_STLP_alloc_proxy@PAUString@CGameFont@@U12@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@PAUString@CGameFont@@@Z ; stlp_std::priv::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >
	mov	eax, esi
	ret	0
??0?$_Vector_base@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z ENDP ; stlp_std::priv::_Vector_base<CGameFont::String,xalloc<CGameFont::String> >::_Vector_base<CGameFont::String,xalloc<CGameFont::String> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z PROC ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >, COMDAT
; _this$ = esi
; ___a$ = eax

; 208  :     : _STLP_PRIV _Vector_base<_Tp, _Alloc>(__a) {}

	push	0
	push	eax
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	call	??0?$_STLP_alloc_proxy@PAUString@CGameFont@@U12@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@PAUString@CGameFont@@@Z ; stlp_std::priv::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >
	mov	eax, esi
	ret	0
??0?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z ENDP ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@PAU34@0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?erase@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@PAU34@0@Z PROC ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::erase, COMDAT
; ___first$ = ecx
; ___last$ = eax

; 208  :     return cast_traits::to_value_type_ptr(_M_impl.erase(cast_traits::to_storage_type_ptr(__first),
; 209  :                                                         cast_traits::to_storage_type_ptr(__last)));

	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+4]
	call	?erase@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@PAU45@0@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::erase

; 210  :   }

	ret	4
?erase@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEPAUString@CGameFont@@PAU34@0@Z ENDP ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z
_TEXT	SEGMENT
??0?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z PROC ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::vector<CGameFont::String,xalloc<CGameFont::String> >, COMDAT
; _this$ = esi
; ___a$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	push	0
	push	eax
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	call	??0?$_STLP_alloc_proxy@PAUString@CGameFont@@U12@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@PAUString@CGameFont@@@Z ; stlp_std::priv::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >
	mov	eax, esi
	ret	0
??0?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@@Z ENDP ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::vector<CGameFont::String,xalloc<CGameFont::String> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?clear_not_free@?$xr_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_not_free@?$xr_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@@QAEXXZ PROC ; xr_vector<CGameFont::String,xalloc<CGameFont::String> >::clear_not_free, COMDAT
; _this$ = esi

; 129  : 	void	clear_not_free		()									{ erase(begin(),end());			}

	push	edi
	mov	ecx, esi
	call	?end@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@XZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::end
	mov	ecx, esi
	mov	edi, eax
	call	?begin@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@XZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::begin
	push	edi
	push	eax
	mov	ecx, esi
	call	?erase@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@PAU45@0@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::erase
	pop	edi
	ret	0
?clear_not_free@?$xr_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@@QAEXXZ ENDP ; xr_vector<CGameFont::String,xalloc<CGameFont::String> >::clear_not_free
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@@QAE@XZ
_TEXT	SEGMENT
$T292233 = -1						; size = 1
??0?$xr_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@@QAE@XZ PROC ; xr_vector<CGameFont::String,xalloc<CGameFont::String> >::xr_vector<CGameFont::String,xalloc<CGameFont::String> >, COMDAT
; _this$ = esi

; 123  : 			xr_vector			()									: inherited	()					{}

	push	ecx
	push	0
	lea	eax, DWORD PTR $T292233[esp+8]
	push	eax
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	call	??0?$_STLP_alloc_proxy@PAUString@CGameFont@@U12@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@PAUString@CGameFont@@@Z ; stlp_std::priv::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$xr_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@@QAE@XZ ENDP ; xr_vector<CGameFont::String,xalloc<CGameFont::String> >::xr_vector<CGameFont::String,xalloc<CGameFont::String> >
_TEXT	ENDS
PUBLIC	?SplitByWidth@CGameFont@@QAEGPAGGMPBD@Z		; CGameFont::SplitByWidth
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\gamefont.cpp
;	COMDAT ?SplitByWidth@CGameFont@@QAEGPAGGMPBD@Z
_TEXT	SEGMENT
_this$ = -16396						; size = 4
_fDelta$ = -16392					; size = 4
tv256 = -16388						; size = 4
_wsStr$ = -16384					; size = 8192
_wsPos$ = -8192						; size = 8224
_puBuffer$ = 8						; size = 4
_uBufferSize$ = 12					; size = 2
_fTargetWidth$ = 16					; size = 4
_pszText$ = 20						; size = 4
?SplitByWidth@CGameFont@@QAEGPAGGMPBD@Z PROC		; CGameFont::SplitByWidth, COMDAT
; _this$ = ecx

; 223  : {

	mov	eax, 16396				; 0000400cH
	call	__chkstk

; 224  : 	VERIFY( puBuffer && uBufferSize && pszText );
; 225  : 
; 226  : 	wide_char wsStr[ MAX_MB_CHARS ] , wsPos[ MAX_MB_CHARS ];
; 227  : 	float fCurWidth = 0.0f , fDelta = 0.0f;
; 228  : 	u16 nLines = 0;
; 229  : 
; 230  : 	u16	len	= mbhMulti2Wide( wsStr , wsPos , MAX_MB_CHARS , pszText );

	mov	eax, DWORD PTR _pszText$[esp+16392]
	xorps	xmm1, xmm1
	push	ebx
	push	ebp
	push	edi
	push	eax
	mov	DWORD PTR _this$[esp+16412], ecx
	push	4096					; 00001000H
	lea	ecx, DWORD PTR _wsPos$[esp+16416]
	push	ecx
	lea	edx, DWORD PTR _wsStr$[esp+16420]
	push	edx
	xor	ebp, ebp
	call	?mbhMulti2Wide@@YAGPAG0GPBD@Z		; mbhMulti2Wide
	movzx	ebx, ax

; 231  : 
; 232  : 	for ( u16 i = 1 ; i <= len ; i++ ) {

	lea	edi, DWORD PTR [ebp+1]
	add	esp, 16					; 00000010H
	cmp	bx, di
	jb	$LN29@SplitByWid
	push	esi
	xor	esi, esi
	npad	6
$LL9@SplitByWid:

; 233  : 
; 234  : 		fDelta = GetCharTC( wsStr[ i ] ).z - 2;

	movzx	eax, WORD PTR _wsStr$[esp+esi+16414]
	mov	edx, DWORD PTR _this$[esp+16412]
	mov	edx, DWORD PTR [edx+44]
	movzx	ecx, ax
	lea	ecx, DWORD PTR [ecx+ecx*2]
	movss	xmm0, DWORD PTR [edx+ecx*4+8]
	subss	xmm0, DWORD PTR __real@40000000

; 235  : 
; 236  : 		if ( IsNeedSpaceCharacter( wsStr[ i ] ) )

	movzx	ecx, ax
	cmp	cx, 32					; 00000020H
	movss	DWORD PTR _fDelta$[esp+16412], xmm0
	je	SHORT $LN19@SplitByWid
	cmp	cx, 12288				; 00003000H
	je	SHORT $LN19@SplitByWid
	cmp	cx, 65281				; 0000ff01H
	je	SHORT $LN19@SplitByWid
	cmp	cx, 65292				; 0000ff0cH
	je	SHORT $LN19@SplitByWid
	cmp	cx, 65294				; 0000ff0eH
	je	SHORT $LN19@SplitByWid
	cmp	cx, 65306				; 0000ff1aH
	je	SHORT $LN19@SplitByWid
	cmp	cx, 65307				; 0000ff1bH
	je	SHORT $LN19@SplitByWid
	cmp	cx, 65311				; 0000ff1fH
	je	SHORT $LN19@SplitByWid
	cmp	cx, 8230				; 00002026H
	je	SHORT $LN19@SplitByWid
	cmp	cx, 12290				; 00003002H
	je	SHORT $LN19@SplitByWid
	cmp	cx, 12289				; 00003001H
	jne	SHORT $LN6@SplitByWid
$LN19@SplitByWid:

; 237  : 			fDelta += fXStep;

	mov	ecx, DWORD PTR _this$[esp+16412]
	movss	xmm2, DWORD PTR [ecx+52]
	addss	xmm2, xmm0
	movaps	xmm0, xmm2
	movss	DWORD PTR _fDelta$[esp+16412], xmm0
$LN6@SplitByWid:

; 238  : 
; 239  : 		if ( 
; 240  : 				( ( fCurWidth + fDelta ) > fTargetWidth ) && // overlength
; 241  : 				( ! IsBadStartCharacter( wsStr[ i ] ) ) && // can start with this character
; 242  : 				( i < len ) && // is not the last character
; 243  : 				( ( i > 1 ) && ( ! IsBadEndCharacter( wsStr[ i - 1 ] ) ) ) // && // do not stop the string on a "bad" character
; 244  : //				( ( i > 1 ) && ( ! ( ( IsAlphaCharacter( wsStr[ i - 1 ] ) ) && (  IsAlphaCharacter( wsStr[ i ] ) ) ) ) ) // do not split numbers or words
; 245  : 		) {

	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR _fTargetWidth$[esp+16408]
	movss	DWORD PTR tv256[esp+16412], xmm0
	jbe	SHORT $LN32@SplitByWid
	call	?IsBadStartCharacter@@YAHG@Z		; IsBadStartCharacter
	test	eax, eax
	jne	SHORT $LN31@SplitByWid
	cmp	di, bx
	jae	SHORT $LN31@SplitByWid
	cmp	di, 1
	jbe	SHORT $LN31@SplitByWid
	movzx	eax, WORD PTR _wsStr$[esp+esi+16412]
	cmp	ax, 40					; 00000028H
	je	SHORT $LN31@SplitByWid
	cmp	ax, 65288				; 0000ff08H
	je	SHORT $LN31@SplitByWid
	cmp	ax, 19968				; 00004e00H
	je	SHORT $LN31@SplitByWid

; 246  : 			fCurWidth = fDelta;
; 247  : 			VERIFY( nLines < uBufferSize );
; 248  : 			puBuffer[ nLines++ ] = wsPos[ i - 1 ];

	mov	ax, WORD PTR _wsPos$[esp+esi+16412]
	mov	ecx, DWORD PTR _puBuffer$[esp+16408]
	movss	xmm1, DWORD PTR _fDelta$[esp+16412]
	movzx	edx, bp
	mov	WORD PTR [ecx+edx*2], ax
	add	ebp, 1

; 249  : 		} else 

	jmp	SHORT $LN8@SplitByWid
$LN31@SplitByWid:
	movss	xmm0, DWORD PTR tv256[esp+16412]
$LN32@SplitByWid:

; 250  : 			fCurWidth += fDelta;

	movaps	xmm1, xmm0
$LN8@SplitByWid:

; 231  : 
; 232  : 	for ( u16 i = 1 ; i <= len ; i++ ) {

	add	edi, 1
	add	esi, 2
	cmp	di, bx
	jbe	$LL9@SplitByWid
	pop	esi
$LN29@SplitByWid:
	pop	edi

; 251  : 	}
; 252  : 
; 253  : 	return nLines;

	mov	ax, bp
	pop	ebp
	pop	ebx

; 254  : }

	add	esp, 16396				; 0000400cH
	ret	16					; 00000010H
?SplitByWidth@CGameFont@@QAEGPAGGMPBD@Z ENDP		; CGameFont::SplitByWidth
_TEXT	ENDS
PUBLIC	?OnRender@CGameFont@@QAEXXZ			; CGameFont::OnRender
; Function compile flags: /Ogtpy
;	COMDAT ?OnRender@CGameFont@@QAEXXZ
_TEXT	SEGMENT
?OnRender@CGameFont@@QAEXXZ PROC			; CGameFont::OnRender, COMDAT
; _this$ = ecx

; 192  : {

	push	esi
	mov	esi, ecx

; 193  : 	pFontRender->OnRender(*this);

	mov	ecx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	push	esi
	call	edx

; 194  : 	strings.clear_not_free();

	add	esi, 64					; 00000040H
	mov	ecx, esi
	call	?end@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@XZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::end
	mov	ecx, esi
	mov	edi, eax
	call	?begin@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@XZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::begin
	push	edi
	push	eax
	mov	ecx, esi
	call	?erase@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@PAU45@0@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::erase
	pop	edi
	pop	esi

; 195  : }

	ret	0
?OnRender@CGameFont@@QAEXXZ ENDP			; CGameFont::OnRender
_TEXT	ENDS
PUBLIC	??1CGameFont@@QAE@XZ				; CGameFont::~CGameFont
; Function compile flags: /Ogtpy
;	COMDAT ??1CGameFont@@QAE@XZ
_TEXT	SEGMENT
??1CGameFont@@QAE@XZ PROC				; CGameFont::~CGameFont, COMDAT
; _this$ = ecx

; 164  : {

	push	esi
	mov	esi, ecx

; 165  : 	if ( TCMap )

	cmp	DWORD PTR [esi+44], 0
	lea	eax, DWORD PTR [esi+44]
	je	SHORT $LN1@CGameFont

; 166  : 		xr_free( TCMap );

	push	eax
	call	??$xr_free@U?$_vector3@M@@@@YAXAAPAU?$_vector3@M@@@Z ; xr_free<_vector3<float> >
	add	esp, 4
$LN1@CGameFont:

; 167  : 
; 168  : 	// Shading
; 169  : 	RenderFactory->DestroyFontRender(pFontRender);

	mov	eax, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [edx+132]
	push	eax
	call	edx

; 170  : }

	lea	ecx, DWORD PTR [esi+64]
	pop	esi
	jmp	??1?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::~_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >
??1CGameFont@@QAE@XZ ENDP				; CGameFont::~CGameFont
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
;	COMDAT ?reserve@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEXI@Z
_TEXT	SEGMENT
___n$ = -4						; size = 4
?reserve@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEXI@Z PROC ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::reserve, COMDAT
; _this$ = esi

; 64   : void vector<_Tp, _Alloc>::reserve(size_type __n) {

	push	ecx

; 65   :   if (capacity() < __n) {

	mov	ecx, esi
	mov	DWORD PTR ___n$[esp+4], 128		; 00000080H
	call	?capacity@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::capacity
	mov	ecx, DWORD PTR ___n$[esp+4]
	cmp	eax, ecx
	jae	SHORT $LN24@reserve

; 66   :     if (max_size() < __n) {

	cmp	ecx, 4113953				; 003ec621H
	jbe	SHORT $LN3@reserve

; 67   :       this->_M_throw_length_error();

	push	OFFSET ??_C@_06NBFPPGEG@vector?$AA@
	call	DWORD PTR __imp__puts
	add	esp, 4
	call	DWORD PTR __imp__abort
$LN27@reserve:
$LN3@reserve:
	push	ebx
	push	ebp
	push	edi

; 68   :     }
; 69   : 
; 70   :     const size_type __old_size = size();

	mov	ecx, esi
	call	?size@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::size

; 71   :     pointer __tmp;
; 72   :     if (this->_M_start) {

	mov	ebx, DWORD PTR [esi]
	test	ebx, ebx
	mov	ebp, eax
	je	SHORT $LN2@reserve

; 73   :       __tmp = _M_allocate_and_copy(__n, this->_M_start, this->_M_finish);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	lea	eax, DWORD PTR ___n$[esp+20]
	mov	ecx, esi
	call	??$_M_allocate_and_copy@PAUString@CGameFont@@@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEPAUString@CGameFont@@AAIPAU34@1@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_allocate_and_copy<CGameFont::String *>

; 74   :       _M_clear();

	mov	ecx, esi
	mov	edi, eax
	call	?_M_clear@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_clear

; 75   :     } else {

	jmp	SHORT $LN1@reserve
$LN2@reserve:

; 76   :       __tmp = this->_M_end_of_storage.allocate(__n, __n);

	mov	edx, DWORD PTR ___n$[esp+16]
	lea	ecx, DWORD PTR ___n$[esp+16]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [esi+8]
	call	?allocate@?$_STLP_alloc_proxy@PAUString@CGameFont@@U12@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >::allocate
	mov	edi, eax
$LN1@reserve:

; 77   :     }
; 78   :     _M_set(__tmp, __tmp + __old_size, __tmp + __n);

	mov	eax, DWORD PTR ___n$[esp+16]
	imul	ebp, 1044				; 00000414H
	imul	eax, 1044				; 00000414H
	add	ebp, edi
	add	eax, edi
	mov	DWORD PTR [esi], edi
	pop	edi
	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	mov	DWORD PTR [esi+8], eax
	pop	ebx
$LN24@reserve:

; 79   :   }
; 80   : }

	pop	ecx
	ret	0
$LN26@reserve:
?reserve@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEXI@Z ENDP ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::reserve
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_insert_overflow@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@ABU45@ABU__true_type@3@I_N@Z
_TEXT	SEGMENT
___fill_len$ = -16					; size = 4
___len$ = -12						; size = 4
___new_start$ = -8					; size = 4
tv163 = -4						; size = 4
___old_size$ = 8					; size = 4
_this$ = 8						; size = 4
___x$ = 12						; size = 4
?_M_insert_overflow@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@ABU45@ABU__true_type@3@I_N@Z PROC ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_insert_overflow, COMDAT
; ___pos$ = eax

; 109  :                                              size_type __fill_len, bool __atend ) {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+20]
	push	esi
	push	edi

; 110  :   const size_type __old_size = size();

	mov	ecx, ebp
	mov	esi, eax
	mov	DWORD PTR ___fill_len$[esp+32], 1
	call	?size@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::size
	mov	DWORD PTR ___old_size$[esp+28], eax

; 111  :   size_type __len = __old_size + (max)(__old_size, __fill_len);

	lea	eax, DWORD PTR ___fill_len$[esp+32]
	push	eax
	lea	ecx, DWORD PTR ___old_size$[esp+32]
	push	ecx
	call	??$max@I@stlp_std@@YAABIABI0@Z		; stlp_std::max<unsigned int>
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR ___old_size$[esp+36]
	add	esp, 8

; 112  : 
; 113  :   pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);

	lea	edx, DWORD PTR ___len$[esp+32]
	push	edx
	lea	ecx, DWORD PTR [ebp+8]
	push	eax
	mov	DWORD PTR ___len$[esp+40], eax
	mov	DWORD PTR tv163[esp+40], ecx
	call	?allocate@?$_STLP_alloc_proxy@PAUString@CGameFont@@U12@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEPAUString@CGameFont@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >::allocate
	mov	edi, eax

; 114  :   pointer __new_finish = __STATIC_CAST(pointer, _STLP_PRIV __copy_trivial(this->_M_start, __pos, __new_start));

	mov	eax, DWORD PTR [ebp]
	sub	esi, eax
	mov	DWORD PTR ___new_start$[esp+32], edi
	je	SHORT $LN22@M_insert_o@10
	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	jmp	SHORT $LN23@M_insert_o@10
$LN22@M_insert_o@10:
	mov	eax, edi
$LN23@M_insert_o@10:

; 115  :   // handle insertion
; 116  :   __new_finish = _STLP_PRIV __fill_n(__new_finish, __fill_len, __x);

	mov	edx, DWORD PTR ___fill_len$[esp+32]
	test	edx, edx
	mov	ebx, eax
	jbe	SHORT $LN24@M_insert_o@10
$LL26@M_insert_o@10:
	mov	esi, DWORD PTR ___x$[esp+28]
	mov	edi, ebx
	sub	edx, 1
	mov	ecx, 261				; 00000105H
	add	ebx, 1044				; 00000414H
	test	edx, edx
	rep movsd
	ja	SHORT $LL26@M_insert_o@10
	mov	edi, DWORD PTR ___new_start$[esp+32]
$LN24@M_insert_o@10:

; 117  :   if (!__atend)
; 118  :     __new_finish = __STATIC_CAST(pointer, _STLP_PRIV __copy_trivial(__pos, this->_M_finish, __new_finish)); // copy remainder
; 119  :   _M_clear();

	mov	ecx, ebp
	call	?_M_clear@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_clear

; 120  :   _M_set(__new_start, __new_finish, __new_start + __len);

	mov	eax, DWORD PTR ___len$[esp+32]
	mov	ecx, DWORD PTR tv163[esp+32]
	imul	eax, 1044				; 00000414H
	mov	DWORD PTR [ebp], edi
	add	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp+4], ebx
	pop	ebp
	mov	DWORD PTR [ecx], eax
	pop	ebx

; 121  : }

	add	esp, 16					; 00000010H
	ret	8
?_M_insert_overflow@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@ABU45@ABU__true_type@3@I_N@Z ENDP ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_insert_overflow
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEXABUString@CGameFont@@@Z
_TEXT	SEGMENT
?push_back@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEXABUString@CGameFont@@@Z PROC ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::push_back, COMDAT
; _this$ = edx
; ___x$ = eax

; 360  :   void push_back(const _Tp& __x) {

	push	esi
	mov	esi, eax

; 361  : #endif /*!_STLP_DONT_SUP_DFLT_PARAM && !_STLP_NO_ANACHRONISMS*/
; 362  :     if (this->_M_finish != this->_M_end_of_storage._M_data) {

	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN2@push_back@18

; 363  :       _Copy_Construct(this->_M_finish, __x);

	test	eax, eax
	je	SHORT $LN7@push_back@18
	push	edi
	mov	ecx, 261				; 00000105H
	mov	edi, eax
	rep movsd
	pop	edi
$LN7@push_back@18:

; 364  :       ++this->_M_finish;

	add	DWORD PTR [edx+4], 1044			; 00000414H
	pop	esi

; 368  :   }

	ret	0
$LN2@push_back@18:

; 365  :     }
; 366  :     else
; 367  :       _M_insert_overflow(this->_M_finish, __x, _TrivialCopy(), 1UL, true);

	push	esi
	push	edx
	call	?_M_insert_overflow@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_insert_overflow
	pop	esi

; 368  :   }

	ret	0
?push_back@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEXABUString@CGameFont@@@Z ENDP ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::push_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEXABUString@CGameFont@@@Z
_TEXT	SEGMENT
?push_back@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEXABUString@CGameFont@@@Z PROC ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::push_back, COMDAT
; _this$ = edx
; ___x$ = eax

; 171  :   { _M_impl.push_back(cast_traits::to_storage_type_cref(__x)); }

	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN6@push_back@19
	test	eax, eax
	je	SHORT $LN11@push_back@19
	push	edi
	mov	ecx, 261				; 00000105H
	mov	edi, eax
	rep movsd
	pop	edi
$LN11@push_back@19:
	add	DWORD PTR [edx+4], 1044			; 00000414H
	pop	esi
	ret	0
$LN6@push_back@19:
	push	esi
	push	edx
	call	?_M_insert_overflow@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_insert_overflow
	pop	esi
	ret	0
?push_back@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEXABUString@CGameFont@@@Z ENDP ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?reserve@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEXI@Z
_TEXT	SEGMENT
?reserve@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEXI@Z PROC ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::reserve, COMDAT
; _this$ = esi

; 151  :   void reserve(size_type __n) {_M_impl.reserve(__n);}

	jmp	?reserve@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEXI@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::reserve
?reserve@?$vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@stlp_std@@QAEXI@Z ENDP ; stlp_std::vector<CGameFont::String,xalloc<CGameFont::String> >::reserve
_TEXT	ENDS
PUBLIC	?MasterOut@CGameFont@@QAEXHHHHMMMPBDPAD@Z	; CGameFont::MasterOut
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\gamefont.cpp
;	COMDAT ?MasterOut@CGameFont@@QAEXHHHHMMMPBDPAD@Z
_TEXT	SEGMENT
tv436 = -1048						; size = 4
tv416 = -1048						; size = 4
_a$368298 = -1048					; size = 4
_a$368290 = -1048					; size = 4
_rs$ = -1044						; size = 1044
_bCheckDevice$ = 8					; size = 4
_bUseCoords$ = 12					; size = 4
_bScaleCoords$ = 16					; size = 4
_bUseSkip$ = 20						; size = 4
__x$ = 24						; size = 4
__y$ = 28						; size = 4
__skip$ = 32						; size = 4
_fmt$ = 36						; size = 4
_p$ = 40						; size = 4
?MasterOut@CGameFont@@QAEXHHHHMMMPBDPAD@Z PROC		; CGameFont::MasterOut, COMDAT
; _this$ = ecx

; 259  : {

	sub	esp, 1048				; 00000418H

; 260  : 	if ( bCheckDevice && ( ! RDEVICE.b_is_Active ) )

	cmp	DWORD PTR _bCheckDevice$[esp+1044], 0
	push	ebx
	mov	ebx, ecx
	je	SHORT $LN4@MasterOut
	cmp	DWORD PTR ?Device@@3VCRenderDevice@@A+20, 0
	je	$LN35@MasterOut
$LN4@MasterOut:

; 261  : 		return;
; 262  : 
; 263  : 	String rs;
; 264  : 
; 265  : 	rs.x = ( bUseCoords ? ( bScaleCoords ? ( DI2PX( _x ) ) : _x ) : fCurrentX );

	cmp	DWORD PTR _bUseCoords$[esp+1048], 0
	push	esi
	je	$LN9@MasterOut
	cmp	DWORD PTR _bScaleCoords$[esp+1052], 0
	je	$LN7@MasterOut
	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+40]
	call	eax
	test	eax, eax
	mov	DWORD PTR tv436[esp+1056], eax
	fild	DWORD PTR tv436[esp+1056]
	jge	SHORT $LN40@MasterOut
	fadd	DWORD PTR __real@4f800000
$LN40@MasterOut:
	fld	DWORD PTR __x$[esp+1052]
	mov	ecx, 158				; 0000009eH
	fadd	DWORD PTR __real@3f800000
	mov	eax, 1
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@3f000000
	fstp	DWORD PTR _a$368290[esp+1056]
	mov	esi, DWORD PTR _a$368290[esp+1056]
	mov	edx, esi
	sar	edx, 23					; 00000017H
	and	edx, 255				; 000000ffH
	sub	ecx, edx
	mov	edx, esi
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	shl	eax, cl
	sub	eax, 1
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	add	eax, 1
	sar	esi, 31					; 0000001fH
	and	eax, esi
	sub	edx, eax

; 266  : 	rs.y = ( bUseCoords ? ( bScaleCoords ? ( DI2PY( _y ) ) : _y ) : fCurrentY );

	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	add	ecx, 64					; 00000040H
	sar	ecx, 31					; 0000001fH
	and	edx, ecx
	xor	edx, esi
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _rs$[esp+2080], xmm0
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+44]
	call	eax
	test	eax, eax
	mov	DWORD PTR tv416[esp+1056], eax
	fild	DWORD PTR tv416[esp+1056]
	jge	SHORT $LN41@MasterOut
	fadd	DWORD PTR __real@4f800000
$LN41@MasterOut:
	fld	DWORD PTR __y$[esp+1052]
	mov	ecx, 158				; 0000009eH
	fadd	DWORD PTR __real@3f800000
	mov	eax, 1
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@3f000000
	fstp	DWORD PTR _a$368298[esp+1056]
	mov	esi, DWORD PTR _a$368298[esp+1056]
	mov	edx, esi
	sar	edx, 23					; 00000017H
	and	edx, 255				; 000000ffH
	sub	ecx, edx
	mov	edx, esi
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	shl	eax, cl
	sub	eax, 1
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	add	eax, 1
	sar	esi, 31					; 0000001fH
	and	eax, esi
	add	ecx, 64					; 00000040H
	sub	edx, eax
	sar	ecx, 31					; 0000001fH
	and	edx, ecx
	xor	edx, esi
	cvtsi2ss xmm0, edx
	jmp	SHORT $LN42@MasterOut
$LN7@MasterOut:

; 261  : 		return;
; 262  : 
; 263  : 	String rs;
; 264  : 
; 265  : 	rs.x = ( bUseCoords ? ( bScaleCoords ? ( DI2PX( _x ) ) : _x ) : fCurrentX );

	movss	xmm0, DWORD PTR __x$[esp+1052]
	movss	DWORD PTR _rs$[esp+2080], xmm0

; 266  : 	rs.y = ( bUseCoords ? ( bScaleCoords ? ( DI2PY( _y ) ) : _y ) : fCurrentY );

	movss	xmm0, DWORD PTR __y$[esp+1052]
	jmp	SHORT $LN42@MasterOut
$LN9@MasterOut:

; 261  : 		return;
; 262  : 
; 263  : 	String rs;
; 264  : 
; 265  : 	rs.x = ( bUseCoords ? ( bScaleCoords ? ( DI2PX( _x ) ) : _x ) : fCurrentX );

	movss	xmm0, DWORD PTR [ebx+28]
	movss	DWORD PTR _rs$[esp+2080], xmm0

; 266  : 	rs.y = ( bUseCoords ? ( bScaleCoords ? ( DI2PY( _y ) ) : _y ) : fCurrentY );

	movss	xmm0, DWORD PTR [ebx+32]
$LN42@MasterOut:

; 267  : 	rs.c = dwCurrentColor;

	mov	eax, DWORD PTR [ebx+20]

; 268  : 	rs.height = fCurrentHeight;
; 269  : 	rs.align = eCurrentAlignment;
; 270  : #ifndef	_EDITOR
; 271  : 	int vs_sz = vsprintf_s( rs.string , fmt , p );

	mov	edx, DWORD PTR _p$[esp+1052]
	mov	ecx, DWORD PTR [ebx+16]
	push	edx
	mov	DWORD PTR _rs$[esp+2096], eax
	mov	eax, DWORD PTR _fmt$[esp+1056]
	push	eax
	mov	DWORD PTR _rs$[esp+2104], ecx
	lea	ecx, DWORD PTR _rs$[esp+1064]
	movss	DWORD PTR _rs$[esp+2092], xmm0
	movss	xmm0, DWORD PTR [ebx+24]
	push	1024					; 00000400H
	push	ecx
	movss	DWORD PTR _rs$[esp+2104], xmm0
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H

; 272  : #else
; 273  : 	int vs_sz = vsprintf( rs.string , fmt , p );
; 274  : #endif
; 275  : 	//VERIFY( ( vs_sz != -1 ) && ( rs.string[ vs_sz ] == '\0' ) );
; 276  : 
; 277  : 	rs.string[ sizeof(rs.string)-1 ] = 0;
; 278  : 	if ( vs_sz == -1 )

	cmp	eax, -1
	mov	BYTE PTR _rs$[esp+2079], 0
	je	SHORT $LN39@MasterOut

; 279  : 	{
; 280  : 		return;
; 281  : 	}
; 282  : 
; 283  : 	if ( vs_sz )

	test	eax, eax
	je	SHORT $LN25@MasterOut

; 284  : 		strings.push_back( rs );

	mov	eax, DWORD PTR [ebx+68]
	cmp	eax, DWORD PTR [ebx+72]
	lea	edx, DWORD PTR [ebx+64]
	je	SHORT $LN26@MasterOut
	test	eax, eax
	je	SHORT $LN31@MasterOut
	push	edi
	mov	ecx, 261				; 00000105H
	lea	esi, DWORD PTR _rs$[esp+1060]
	mov	edi, eax
	rep movsd
	pop	edi
$LN31@MasterOut:
	add	DWORD PTR [edx+4], 1044			; 00000414H
	jmp	SHORT $LN25@MasterOut
$LN26@MasterOut:
	lea	ecx, DWORD PTR _rs$[esp+1056]
	push	ecx
	push	edx
	call	?_M_insert_overflow@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_insert_overflow
$LN25@MasterOut:

; 285  : 
; 286  : 	if ( bUseSkip )

	cmp	DWORD PTR _bUseSkip$[esp+1052], 0
	je	SHORT $LN39@MasterOut

; 287  : 		OutSkip( _skip );

	movss	xmm0, DWORD PTR [ebx+40]
	mulss	xmm0, DWORD PTR [ebx+24]
	mulss	xmm0, DWORD PTR __skip$[esp+1052]
	addss	xmm0, DWORD PTR [ebx+32]
	movss	DWORD PTR [ebx+32], xmm0
$LN39@MasterOut:
	pop	esi
$LN35@MasterOut:
	pop	ebx

; 288  : }

	add	esp, 1048				; 00000418H
	ret	36					; 00000024H
?MasterOut@CGameFont@@QAEXHHHHMMMPBDPAD@Z ENDP		; CGameFont::MasterOut
_TEXT	ENDS
PUBLIC	?Initialize@CGameFont@@QAEXPBD0@Z		; CGameFont::Initialize
; Function compile flags: /Ogtpy
;	COMDAT ?Initialize@CGameFont@@QAEXPBD0@Z
_TEXT	SEGMENT
_v$116821 = -1596					; size = 12
_v$116809 = -1596					; size = 12
_v$116802 = -1596					; size = 12
_v$116788 = -1596					; size = 12
tv704 = -1584						; size = 4
tv702 = -1584						; size = 4
_width$116842 = -1584					; size = 4
_vFirstValid$116785 = -1580				; size = 12
tv722 = -1568						; size = 4
tv721 = -1568						; size = 4
_cpl$116844 = -1568					; size = 4
_buf$ = -1564						; size = 520
_cTexture$ = -1044					; size = 520
_fn$ = -524						; size = 520
_cShader$ = 8						; size = 4
_cTextureName$ = 12					; size = 4
?Initialize@CGameFont@@QAEXPBD0@Z PROC			; CGameFont::Initialize, COMDAT
; _this$ = ecx

; 53   : 	string_path					cTexture;
; 54   : 
; 55   : 	LPCSTR _lang				= pSettings->r_string("string_table", "font_prefix");

	mov	eax, DWORD PTR __imp_?pSettings@@3PBVCInifile@@B
	sub	esp, 1596				; 0000063cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	push	OFFSET ??_C@_0M@CLPDPKKE@font_prefix?$AA@
	mov	edi, ecx
	mov	ecx, DWORD PTR [eax]
	push	OFFSET ??_C@_0N@DMNODOPK@string_table?$AA@
	call	DWORD PTR __imp_?r_string@CInifile@@QBEPBDPBD0@Z

; 56   : 	bool is_di					= strstr(cTextureName, "ui_font_hud_01") || 
; 57   : 								  strstr(cTextureName, "ui_font_hud_02") ||
; 58   : 								  strstr(cTextureName, "ui_font_console_02");

	mov	esi, DWORD PTR _cTextureName$[esp+1608]
	mov	ebx, DWORD PTR __imp__strstr
	push	OFFSET ??_C@_0P@FPOFENP@ui_font_hud_01?$AA@
	push	esi
	mov	ebp, eax
	call	ebx
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN40@Initialize@4
	push	OFFSET ??_C@_0P@CONDAHBM@ui_font_hud_02?$AA@
	push	esi
	call	ebx
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN40@Initialize@4
	push	OFFSET ??_C@_0BD@KJKHKIKC@ui_font_console_02?$AA@
	push	esi
	call	ebx
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN40@Initialize@4
	xor	al, al
	jmp	SHORT $LN41@Initialize@4
$LN40@Initialize@4:
	mov	al, 1
$LN41@Initialize@4:

; 59   : 	if(_lang && !is_di)

	test	ebp, ebp
	mov	ebx, DWORD PTR __imp__strncpy_s
	je	SHORT $LN37@Initialize@4
	test	al, al
	jne	SHORT $LN37@Initialize@4

; 60   : 		strconcat				(sizeof(cTexture),cTexture, cTextureName, _lang);

	push	ebp
	push	esi
	lea	ecx, DWORD PTR _cTexture$[esp+1620]
	push	ecx
	push	520					; 00000208H
	call	DWORD PTR __imp_?strconcat@@YAPADHPADPBD1@Z

; 61   : 	else

	jmp	SHORT $LN116@Initialize@4
$LN37@Initialize@4:

; 62   : 		xr_strcpy				(cTexture, sizeof(cTexture), cTextureName);

	push	520					; 00000208H
	push	esi
	lea	edx, DWORD PTR _cTexture$[esp+1620]
	push	520					; 00000208H
	push	edx
	call	ebx
$LN116@Initialize@4:

; 63   : 
; 64   : 	uFlags						&=~fsValid;
; 65   : 	vTS.set						(1.f,1.f); //  !!!
; 66   : 
; 67   : 	eCurrentAlignment			= alLeft;
; 68   : 	vInterval.set				(1.f,1.f);

	fld1
	and	DWORD PTR [edi+84], -5			; fffffffbH
	add	esp, 16					; 00000010H
	sub	esp, 8
	mov	ebp, 1
	fst	DWORD PTR [esp+4]
	mov	DWORD PTR [edi+8], ebp
	fstp	DWORD PTR [esp]
	mov	DWORD PTR [edi+12], ebp
	lea	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR [edi+16], 0
	call	?set@?$_vector2@M@@QAEAAU1@MM@Z		; _vector2<float>::set

; 69   : 
; 70   : 	strings.reserve				(128);

	lea	esi, DWORD PTR [edi+64]
	call	?reserve@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAEXI@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::reserve

; 71   : 
; 72   : 	// check ini exist
; 73   : 	string_path fn,buf;
; 74   : 	xr_strcpy		(buf,cTexture); if (strext(buf)) *strext(buf)=0;

	push	520					; 00000208H
	lea	eax, DWORD PTR _cTexture$[esp+1616]
	push	eax
	lea	ecx, DWORD PTR _buf$[esp+1620]
	push	520					; 00000208H
	push	ecx
	call	ebx
	mov	esi, DWORD PTR __imp__strrchr
	lea	edx, DWORD PTR _buf$[esp+1628]
	push	46					; 0000002eH
	push	edx
	call	esi
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN34@Initialize@4
	lea	eax, DWORD PTR _buf$[esp+1612]
	push	46					; 0000002eH
	push	eax
	call	esi
	add	esp, 8
	mov	BYTE PTR [eax], 0
$LN34@Initialize@4:

; 75   : 	R_ASSERT2	(FS.exist(fn,"$game_textures$",buf,".ini"),fn);

	cmp	BYTE PTR ?ignore_always@?8??Initialize@CGameFont@@QAEXPBD0@Z@4_NA, 0
	jne	SHORT $LN33@Initialize@4
	mov	eax, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	push	OFFSET ??_C@_04PHHEBHMK@?4ini?$AA@
	lea	ecx, DWORD PTR _buf$[esp+1616]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	push	OFFSET ??_C@_0BA@PHFBKPHL@$game_textures$?$AA@
	lea	edx, DWORD PTR _fn$[esp+1624]
	push	edx
	call	DWORD PTR __imp_?exist@CLocatorAPI@@QAEPBUfile@1@AAY0CAI@DPBD11@Z
	test	eax, eax
	jne	SHORT $LN33@Initialize@4
	push	OFFSET ?ignore_always@?8??Initialize@CGameFont@@QAEXPBD0@Z@4_NA
	push	OFFSET ??_C@_0BG@MCALFBGP@CGameFont?3?3Initialize?$AA@
	push	75					; 0000004bH
	push	OFFSET ??_C@_0DB@CNKJHJKA@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	lea	ecx, DWORD PTR _fn$[esp+1628]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ??_C@_0CK@GCOGHIAJ@FS?4exist?$CIfn?0?$CC$game_textures$?$CC?0bu@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD00H0AA_N@Z
$LN33@Initialize@4:

; 76   : 	CInifile* ini				= CInifile::Create(fn);

	lea	edx, DWORD PTR _fn$[esp+1612]
	push	ebp
	push	edx
	call	DWORD PTR __imp_?Create@CInifile@@SAPAV1@PBDH@Z

; 77   : 
; 78   : 	nNumChars = 0x100;
; 79   : 	TCMap = ( Fvector* ) xr_realloc( ( void* ) TCMap , nNumChars * sizeof( Fvector ) );

	mov	ebx, DWORD PTR __imp_?mem_realloc@xrMemory@@QAEPAXPAXI@Z
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR [edi+44]
	push	3072					; 00000c00H
	mov	DWORD PTR [edi+80], 256			; 00000100H
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx

; 80   : 
; 81   : 	if ( ini->section_exist( "mb_symbol_coords" ) ) {

	mov	ebp, DWORD PTR __imp_?section_exist@CInifile@@QBEHPBD@Z
	push	OFFSET ??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@
	mov	ecx, esi
	mov	DWORD PTR [edi+44], eax
	call	ebp
	test	eax, eax
	je	$LN30@Initialize@4

; 82   : 		nNumChars = 0x10000;
; 83   : 		TCMap = ( Fvector* ) xr_realloc( ( void* ) TCMap , nNumChars * sizeof( Fvector ) );

	mov	eax, DWORD PTR [edi+44]
	push	786432					; 000c0000H
	mov	DWORD PTR [edi+80], 65536		; 00010000H
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx

; 84   : 		uFlags |= fsMultibyte;

	or	DWORD PTR [edi+84], 8

; 85   : 		fHeight = ini->r_float( "mb_symbol_coords" , "height" );

	push	OFFSET ??_C@_06LNLHEAAG@height?$AA@
	push	OFFSET ??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@
	mov	ecx, esi
	mov	DWORD PTR [edi+44], eax
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z
	fst	DWORD PTR [edi+48]

; 86   : 		
; 87   : 		fXStep = ceil( fHeight / 2.0f );

	fmul	DWORD PTR __real@3f000000
	push	ecx
	fstp	DWORD PTR [esp]
	call	_ceilf

; 88   : 
; 89   : 		// Searching for the first valid character
; 90   : 
; 91   : 		Fvector vFirstValid = {0,0,0};

	xorps	xmm0, xmm0
	fstp	DWORD PTR [edi+52]

; 92   : 
; 93   : 		if ( ini->line_exist( "mb_symbol_coords" , "09608" ) ) {

	mov	ebp, DWORD PTR __imp_?line_exist@CInifile@@QBEHPBD0@Z
	add	esp, 4
	push	OFFSET ??_C@_05MCHNBA@09608?$AA@
	push	OFFSET ??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@
	mov	ecx, esi
	movss	DWORD PTR _vFirstValid$116785[esp+1620], xmm0
	movss	DWORD PTR _vFirstValid$116785[esp+1624], xmm0
	movss	DWORD PTR _vFirstValid$116785[esp+1628], xmm0
	call	ebp
	test	eax, eax
	je	SHORT $LN29@Initialize@4

; 94   : 			Fvector v = ini->r_fvector3( "mb_symbol_coords" , "09608" );

	push	OFFSET ??_C@_05MCHNBA@09608?$AA@
	push	OFFSET ??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@
	lea	eax, DWORD PTR _v$116788[esp+1620]
	push	eax

; 95   : 			vFirstValid.set( v.x , v.y , 1 + v[2] - v[0] );
; 96   : 		} else 

	jmp	SHORT $LN117@Initialize@4
$LN29@Initialize@4:

; 97   : 		for ( u32 i=0 ; i < nNumChars ; i++ ) {

	xor	ebx, ebx
	cmp	DWORD PTR [edi+80], ebx
	jbe	$LN25@Initialize@4
	npad	5
$LL27@Initialize@4:

; 98   : 			xr_sprintf( buf ,sizeof(buf), "%05d" , i );

	push	ebx
	lea	ecx, DWORD PTR _buf$[esp+1616]
	push	OFFSET ??_C@_04ODOGNJOP@?$CF05d?$AA@
	push	ecx
	mov	eax, 520				; 00000208H
	call	?xr_sprintf@@YAHPADIPBDZZ		; xr_sprintf
	add	esp, 12					; 0000000cH

; 99   : 			if ( ini->line_exist( "mb_symbol_coords" , buf ) ) {

	lea	edx, DWORD PTR _buf$[esp+1612]
	push	edx
	push	OFFSET ??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@
	mov	ecx, esi
	call	ebp
	test	eax, eax
	jne	SHORT $LN103@Initialize@4
	add	ebx, 1
	cmp	ebx, DWORD PTR [edi+80]
	jb	SHORT $LL27@Initialize@4
	jmp	SHORT $LN25@Initialize@4
$LN103@Initialize@4:

; 100  : 				Fvector v = ini->r_fvector3( "mb_symbol_coords" , buf );

	lea	eax, DWORD PTR _buf$[esp+1612]
	push	eax
	push	OFFSET ??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@
	lea	ecx, DWORD PTR _v$116802[esp+1620]
	push	ecx
$LN117@Initialize@4:
	mov	ecx, esi
	call	DWORD PTR __imp_?r_fvector3@CInifile@@QBE?AU?$_vector3@M@@PBD0@Z

; 101  : 				vFirstValid.set( v.x , v.y , 1 + v[2] - v[0] );

	movss	xmm1, DWORD PTR _v$116802[esp+1616]
	movss	xmm0, DWORD PTR _v$116802[esp+1612]
	movss	DWORD PTR _vFirstValid$116785[esp+1616], xmm1
	movss	xmm1, DWORD PTR _v$116802[esp+1620]
	addss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR _vFirstValid$116785[esp+1620], xmm1
	movss	DWORD PTR _vFirstValid$116785[esp+1612], xmm0
$LN25@Initialize@4:

; 102  : 				break;
; 103  : 			}
; 104  : 		}
; 105  : 
; 106  : 		// Filling entire character table
; 107  : 
; 108  : 		for ( u32 i=0 ; i < nNumChars ; i++ ) {

	xor	ebp, ebp
	cmp	DWORD PTR [edi+80], ebp
	jbe	$LN21@Initialize@4
	xor	ebx, ebx
	npad	8
$LL23@Initialize@4:

; 109  : 			xr_sprintf( buf ,sizeof(buf), "%05d" , i );

	push	ebp
	lea	edx, DWORD PTR _buf$[esp+1616]
	push	OFFSET ??_C@_04ODOGNJOP@?$CF05d?$AA@
	push	edx
	mov	eax, 520				; 00000208H
	call	?xr_sprintf@@YAHPADIPBDZZ		; xr_sprintf
	add	esp, 12					; 0000000cH

; 110  : 			if ( ini->line_exist( "mb_symbol_coords" , buf ) ) {

	lea	eax, DWORD PTR _buf$[esp+1612]
	push	eax
	push	OFFSET ??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@
	mov	ecx, esi
	call	DWORD PTR __imp_?line_exist@CInifile@@QBEHPBD0@Z
	test	eax, eax
	je	SHORT $LN20@Initialize@4

; 111  : 				Fvector v = ini->r_fvector3( "mb_symbol_coords" , buf );

	lea	ecx, DWORD PTR _buf$[esp+1612]
	push	ecx
	push	OFFSET ??_C@_0BB@OCEIDBGK@mb_symbol_coords?$AA@
	lea	edx, DWORD PTR _v$116809[esp+1620]
	push	edx
	mov	ecx, esi
	call	DWORD PTR __imp_?r_fvector3@CInifile@@QBE?AU?$_vector3@M@@PBD0@Z

; 112  : 				TCMap[i].set( v.x , v.y , 1 + v[2] - v[0] );

	mov	eax, DWORD PTR [edi+44]
	movss	xmm0, DWORD PTR _v$116809[esp+1620]
	movss	xmm2, DWORD PTR _v$116809[esp+1612]
	movss	xmm1, DWORD PTR _v$116809[esp+1616]
	addss	xmm0, DWORD PTR __real@3f800000
	add	eax, ebx
	subss	xmm0, xmm2
	movss	DWORD PTR [eax], xmm2
	movss	DWORD PTR [eax+4], xmm1
	movss	DWORD PTR [eax+8], xmm0

; 113  : 			} else

	jmp	SHORT $LN22@Initialize@4
$LN20@Initialize@4:

; 114  : 				TCMap[i] = vFirstValid; // "unassigned" unprintable characters

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR _vFirstValid$116785[esp+1612]
	mov	edx, DWORD PTR _vFirstValid$116785[esp+1616]
	add	eax, ebx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _vFirstValid$116785[esp+1620]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
$LN22@Initialize@4:
	add	ebp, 1
	add	ebx, 12					; 0000000cH
	cmp	ebp, DWORD PTR [edi+80]
	jb	$LL23@Initialize@4
$LN21@Initialize@4:

; 115  : 		}
; 116  : 
; 117  : 		// Special case for space
; 118  : 		TCMap[ 0x0020 ].set( 0 , 0 , 0 );

	mov	eax, DWORD PTR [edi+44]
	xorps	xmm0, xmm0
	add	eax, 384				; 00000180H
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm0
	movss	DWORD PTR [eax+8], xmm0

; 119  : 		// Special case for ideographic space
; 120  : 		TCMap[ 0x3000 ].set( 0 , 0 , 0 );

	mov	eax, DWORD PTR [edi+44]
	add	eax, 147456				; 00024000H
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm0
	movss	DWORD PTR [eax+8], xmm0
	jmp	$LN1@Initialize@4
$LN30@Initialize@4:

; 121  : 
; 122  : 
; 123  : 	}else
; 124  : 	if (ini->section_exist("symbol_coords"))

	push	OFFSET ??_C@_0O@PPLHMCEH@symbol_coords?$AA@
	mov	ecx, esi
	call	ebp
	test	eax, eax

; 125  : 	{
; 126  : 		float d						= 0.0f;
; 127  : //.		if(ini->section_exist("width_correction"))
; 128  : //.			d						= ini->r_float("width_correction", "value");
; 129  : 
; 130  : 		fHeight						= ini->r_float("symbol_coords","height");

	mov	ecx, esi
	je	$LN17@Initialize@4
	push	OFFSET ??_C@_06LNLHEAAG@height?$AA@
	push	OFFSET ??_C@_0O@PPLHMCEH@symbol_coords?$AA@
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z
	fstp	DWORD PTR [edi+48]

; 131  : 		for (u32 i=0; i<nNumChars; i++){

	xor	ebp, ebp
	cmp	DWORD PTR [edi+80], ebp
	jbe	$LN1@Initialize@4

; 125  : 	{
; 126  : 		float d						= 0.0f;
; 127  : //.		if(ini->section_exist("width_correction"))
; 128  : //.			d						= ini->r_float("width_correction", "value");
; 129  : 
; 130  : 		fHeight						= ini->r_float("symbol_coords","height");

	xor	ebx, ebx
	npad	9
$LL16@Initialize@4:

; 132  : 			xr_sprintf				(buf,sizeof(buf),"%03d",i);

	push	ebp
	lea	edx, DWORD PTR _buf$[esp+1616]
	push	OFFSET ??_C@_04OHGLKFFN@?$CF03d?$AA@
	push	edx
	mov	eax, 520				; 00000208H
	call	?xr_sprintf@@YAHPADIPBDZZ		; xr_sprintf
	add	esp, 12					; 0000000cH

; 133  : 			Fvector v				= ini->r_fvector3("symbol_coords",buf);

	lea	eax, DWORD PTR _buf$[esp+1612]
	push	eax
	push	OFFSET ??_C@_0O@PPLHMCEH@symbol_coords?$AA@
	lea	ecx, DWORD PTR _v$116821[esp+1620]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?r_fvector3@CInifile@@QBE?AU?$_vector3@M@@PBD0@Z

; 134  : 			TCMap[i].set			(v.x,v.y,v[2]-v[0]+d);

	mov	eax, DWORD PTR [edi+44]
	movss	xmm0, DWORD PTR _v$116821[esp+1620]
	movss	xmm2, DWORD PTR _v$116821[esp+1612]
	movss	xmm1, DWORD PTR _v$116821[esp+1616]
	add	eax, ebx
	subss	xmm0, xmm2
	add	ebp, 1
	movss	DWORD PTR [eax], xmm2
	movss	DWORD PTR [eax+4], xmm1
	movss	DWORD PTR [eax+8], xmm0
	add	ebx, 12					; 0000000cH
	cmp	ebp, DWORD PTR [edi+80]
	jb	SHORT $LL16@Initialize@4

; 135  : 		}

	jmp	$LN1@Initialize@4
$LN17@Initialize@4:

; 136  : 	}else{
; 137  : 	if (ini->section_exist("char widths")){

	push	OFFSET ??_C@_0M@OEPKPAIC@char?5widths?$AA@
	call	ebp
	test	eax, eax
	je	$LN7@Initialize@4

; 138  : 		fHeight					= ini->r_float("char widths","height");

	push	OFFSET ??_C@_06LNLHEAAG@height?$AA@
	push	OFFSET ??_C@_0M@OEPKPAIC@char?5widths?$AA@
	mov	ecx, esi
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z
	fstp	DWORD PTR [edi+48]

; 139  : 		int cpl					= 16;
; 140  : 		for (u32 i=0; i<nNumChars; i++){

	xor	ebp, ebp
	cmp	DWORD PTR [edi+80], ebp
	jbe	$LN1@Initialize@4

; 138  : 		fHeight					= ini->r_float("char widths","height");

	xor	ebx, ebx
	npad	7
$LL11@Initialize@4:

; 141  : 			xr_sprintf			(buf,sizeof(buf),"%d",i);

	push	ebp
	lea	edx, DWORD PTR _buf$[esp+1616]
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	edx
	mov	eax, 520				; 00000208H
	call	?xr_sprintf@@YAHPADIPBDZZ		; xr_sprintf
	add	esp, 12					; 0000000cH

; 142  : 			float w				= ini->r_float("char widths",buf);

	lea	eax, DWORD PTR _buf$[esp+1612]
	push	eax
	push	OFFSET ??_C@_0M@OEPKPAIC@char?5widths?$AA@
	mov	ecx, esi
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z

; 143  : 			TCMap[i].set		((i%cpl)*fHeight,(i/cpl)*fHeight,w);

	fld	DWORD PTR [edi+48]
	mov	eax, DWORD PTR [edi+44]
	mov	ecx, ebp
	shr	ecx, 4
	add	eax, ebx
	test	ecx, ecx
	mov	DWORD PTR tv722[esp+1612], ecx
	fild	DWORD PTR tv722[esp+1612]
	jge	SHORT $LN112@Initialize@4
	fadd	DWORD PTR __real@4f800000
$LN112@Initialize@4:
	mov	edx, ebp
	fmul	ST(0), ST(1)
	and	edx, 15					; 0000000fH
	test	edx, edx
	mov	DWORD PTR tv721[esp+1612], edx
	fild	DWORD PTR tv721[esp+1612]
	jge	SHORT $LN113@Initialize@4
	fadd	DWORD PTR __real@4f800000
$LN113@Initialize@4:
	fmulp	ST(2), ST(0)
	add	ebp, 1
	fxch	ST(1)
	add	ebx, 12					; 0000000cH
	fstp	DWORD PTR [eax]
	fstp	DWORD PTR [eax+4]
	fstp	DWORD PTR [eax+8]
	cmp	ebp, DWORD PTR [edi+80]
	jb	SHORT $LL11@Initialize@4

; 144  : 		}

	jmp	$LN1@Initialize@4
$LN7@Initialize@4:

; 145  : 	}else{
; 146  : 		R_ASSERT(ini->section_exist("font_size"));

	cmp	BYTE PTR ?ignore_always@?CO@??Initialize@CGameFont@@QAEXPBD0@Z@4_NA, 0
	jne	SHORT $LN6@Initialize@4
	push	OFFSET ??_C@_09NKHIABKK@font_size?$AA@
	mov	ecx, esi
	call	ebp
	test	eax, eax
	jne	SHORT $LN6@Initialize@4
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?CO@??Initialize@CGameFont@@QAEXPBD0@Z@4_NA
	push	OFFSET ??_C@_0BG@MCALFBGP@CGameFont?3?3Initialize?$AA@
	push	146					; 00000092H
	push	OFFSET ??_C@_0DB@CNKJHJKA@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0CA@POEFCMDI@ini?9?$DOsection_exist?$CI?$CCfont_size?$CC?$CJ?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN6@Initialize@4:

; 147  : 		fHeight					= ini->r_float("font_size","height");

	push	OFFSET ??_C@_06LNLHEAAG@height?$AA@
	push	OFFSET ??_C@_09NKHIABKK@font_size?$AA@
	mov	ecx, esi
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z
	fstp	DWORD PTR [edi+48]

; 148  : 		float width				= ini->r_float("font_size","width");

	push	OFFSET ??_C@_05IGKADHGO@width?$AA@
	push	OFFSET ??_C@_09NKHIABKK@font_size?$AA@
	mov	ecx, esi
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z
	fstp	DWORD PTR _width$116842[esp+1612]

; 149  : 		const int cpl			= ini->r_s32	("font_size","cpl");

	push	OFFSET ??_C@_03GKJBDEPF@cpl?$AA@
	push	OFFSET ??_C@_09NKHIABKK@font_size?$AA@
	mov	ecx, esi
	call	DWORD PTR __imp_?r_s32@CInifile@@QBEHPBD0@Z

; 150  : 		for (u32 i=0; i<nNumChars; i++)

	xor	ebp, ebp
	cmp	DWORD PTR [edi+80], ebp
	mov	DWORD PTR _cpl$116844[esp+1612], eax
	jbe	SHORT $LN1@Initialize@4
	movss	xmm0, DWORD PTR _width$116842[esp+1612]
	fld	DWORD PTR _width$116842[esp+1612]
	xor	ebx, ebx
$LN3@Initialize@4:

; 151  : 			TCMap[i].set		((i%cpl)*width,(i/cpl)*fHeight,width);

	xor	edx, edx
	mov	eax, ebp
	div	DWORD PTR _cpl$116844[esp+1612]
	mov	ecx, DWORD PTR [edi+44]
	add	ecx, ebx
	test	eax, eax
	mov	DWORD PTR tv704[esp+1612], eax
	fild	DWORD PTR tv704[esp+1612]
	jge	SHORT $LN114@Initialize@4
	fadd	DWORD PTR __real@4f800000
$LN114@Initialize@4:
	test	edx, edx
	fmul	DWORD PTR [edi+48]
	mov	DWORD PTR tv702[esp+1612], edx
	fild	DWORD PTR tv702[esp+1612]
	jge	SHORT $LN115@Initialize@4
	fadd	DWORD PTR __real@4f800000
$LN115@Initialize@4:
	fmul	ST(0), ST(2)
	add	ebp, 1
	movss	DWORD PTR [ecx+8], xmm0
	add	ebx, 12					; 0000000cH
	fstp	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+4]
	cmp	ebp, DWORD PTR [edi+80]
	jb	SHORT $LN3@Initialize@4

; 150  : 		for (u32 i=0; i<nNumChars; i++)

	fstp	ST(0)
$LN1@Initialize@4:

; 152  : 		}
; 153  : 	}
; 154  : 
; 155  : 	fCurrentHeight				= fHeight;

	fld	DWORD PTR [edi+48]

; 156  : 
; 157  : 	CInifile::Destroy			(ini);

	push	esi
	fstp	DWORD PTR [edi+24]
	call	DWORD PTR __imp_?Destroy@CInifile@@SAXPAV1@@Z

; 158  : 
; 159  : 	// Shading
; 160  : 	pFontRender->Initialize(cShader, cTexture);

	mov	ecx, DWORD PTR [edi+76]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	esp, 4
	lea	edx, DWORD PTR _cTexture$[esp+1612]
	push	edx
	mov	edx, DWORD PTR _cShader$[esp+1612]
	push	edx
	call	eax

; 161  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 1596				; 0000063cH
	ret	8
?Initialize@CGameFont@@QAEXPBD0@Z ENDP			; CGameFont::Initialize
_TEXT	ENDS
PUBLIC	??0CGameFont@@QAE@PBD0I@Z			; CGameFont::CGameFont
; Function compile flags: /Ogtpy
;	COMDAT ??0CGameFont@@QAE@PBD0I@Z
_TEXT	SEGMENT
$T368530 = -1						; size = 1
_shader$ = 8						; size = 4
_texture$ = 12						; size = 4
_flags$ = 16						; size = 4
??0CGameFont@@QAE@PBD0I@Z PROC				; CGameFont::CGameFont, COMDAT
; _this$ = ecx

; 40   : {

	push	ecx
	push	esi
	mov	esi, ecx
	push	0
	lea	eax, DWORD PTR $T368530[esp+12]
	push	eax
	lea	ecx, DWORD PTR [esi+72]
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
	call	??0?$_STLP_alloc_proxy@PAUString@CGameFont@@U12@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@PAUString@CGameFont@@@Z ; stlp_std::priv::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >

; 41   : 	pFontRender					= RenderFactory->CreateFontRender();

	mov	ecx, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+128]
	call	eax

; 42   : 	fCurrentHeight				= 0.0f;
; 43   : 	fXStep						= 0.0f;
; 44   : 	fYStep						= 0.0f;
; 45   : 	uFlags						= flags;
; 46   : 	nNumChars					= 0x100;
; 47   : 	TCMap						= NULL;
; 48   : 	Initialize					(shader,texture);

	mov	edx, DWORD PTR _texture$[esp+4]
	mov	ecx, DWORD PTR _flags$[esp+4]
	xorps	xmm0, xmm0
	mov	DWORD PTR [esi+76], eax
	mov	eax, DWORD PTR _shader$[esp+4]
	push	edx
	mov	DWORD PTR [esi+84], ecx
	push	eax
	mov	ecx, esi
	movss	DWORD PTR [esi+24], xmm0
	movss	DWORD PTR [esi+52], xmm0
	movss	DWORD PTR [esi+56], xmm0
	mov	DWORD PTR [esi+80], 256			; 00000100H
	mov	DWORD PTR [esi+44], 0
	call	?Initialize@CGameFont@@QAEXPBD0@Z	; CGameFont::Initialize

; 49   : }

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	12					; 0000000cH
??0CGameFont@@QAE@PBD0I@Z ENDP				; CGameFont::CGameFont
_TEXT	ENDS
PUBLIC	??0CGameFont@@QAE@PBDI@Z			; CGameFont::CGameFont
; Function compile flags: /Ogtpy
;	COMDAT ??0CGameFont@@QAE@PBDI@Z
_TEXT	SEGMENT
$T368568 = -9						; size = 1
$T368543 = -8						; size = 8
_section$ = 8						; size = 4
tv232 = 12						; size = 4
_sz$116729 = 12						; size = 4
_flags$ = 12						; size = 4
??0CGameFont@@QAE@PBDI@Z PROC				; CGameFont::CGameFont, COMDAT
; _this$ = ecx

; 21   : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
	mov	esi, ecx
	push	edi
	lea	eax, DWORD PTR $T368568[esp+28]
	push	eax
	lea	ecx, DWORD PTR [esi+72]
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	call	??0?$_STLP_alloc_proxy@PAUString@CGameFont@@U12@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UString@CGameFont@@@@PAUString@CGameFont@@@Z ; stlp_std::priv::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >::_STLP_alloc_proxy<CGameFont::String *,CGameFont::String,xalloc<CGameFont::String> >

; 22   : 	pFontRender					= RenderFactory->CreateFontRender();

	mov	ecx, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+128]
	call	eax

; 23   : 	fCurrentHeight				= 0.0f;

	xorps	xmm0, xmm0

; 24   : 	fXStep						= 0.0f;
; 25   : 	fYStep						= 0.0f;
; 26   : 	uFlags						= flags;

	mov	ecx, DWORD PTR _flags$[esp+20]

; 27   : 	nNumChars					= 0x100;
; 28   : 	TCMap						= NULL;
; 29   : 	Initialize	(pSettings->r_string(section,"shader"),pSettings->r_string(section,"texture"));

	mov	ebx, DWORD PTR __imp_?r_string@CInifile@@QBEPBDPBD0@Z
	mov	DWORD PTR [esi+44], edi
	mov	edi, DWORD PTR _section$[esp+20]
	mov	DWORD PTR [esi+76], eax
	movss	DWORD PTR [esi+24], xmm0
	movss	DWORD PTR [esi+52], xmm0
	movss	DWORD PTR [esi+56], xmm0
	mov	DWORD PTR [esi+84], ecx
	mov	DWORD PTR [esi+80], 256			; 00000100H
	mov	edx, DWORD PTR __imp_?pSettings@@3PBVCInifile@@B
	mov	ecx, DWORD PTR [edx]
	push	OFFSET ??_C@_07JDHEGGGP@texture?$AA@
	push	edi
	call	ebx
	push	eax
	mov	eax, DWORD PTR __imp_?pSettings@@3PBVCInifile@@B
	mov	ecx, DWORD PTR [eax]
	push	OFFSET ??_C@_06BILHELBG@shader?$AA@
	push	edi
	call	ebx
	push	eax
	mov	ecx, esi
	call	?Initialize@CGameFont@@QAEXPBD0@Z	; CGameFont::Initialize

; 30   : 	if (pSettings->line_exist(section,"size")){

	mov	ecx, DWORD PTR __imp_?pSettings@@3PBVCInifile@@B
	mov	ecx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR __imp_?line_exist@CInifile@@QBEHPBD0@Z
	push	OFFSET ??_C@_04IAGNFIBA@size?$AA@
	push	edi
	call	ebx
	test	eax, eax
	je	SHORT $LN29@CGameFont@2

; 31   : 		float sz = pSettings->r_float(section,"size");

	mov	edx, DWORD PTR __imp_?pSettings@@3PBVCInifile@@B
	mov	ecx, DWORD PTR [edx]
	push	OFFSET ??_C@_04IAGNFIBA@size?$AA@
	push	edi
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z
	fst	DWORD PTR _sz$116729[esp+20]

; 32   : 		if (uFlags&fsDeviceIndependent)	SetHeightI(sz);

	test	BYTE PTR [esi+84], 2
	je	SHORT $LN37@CGameFont@2
	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+8
	fild	DWORD PTR ?Device@@3VCRenderDevice@@A+8
	test	eax, eax
	jge	SHORT $LN39@CGameFont@2
	fadd	DWORD PTR __real@4f800000
$LN39@CGameFont@2:
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR [esi+24]
	jmp	SHORT $LN29@CGameFont@2
$LN37@CGameFont@2:

; 33   : 		else							SetHeight(sz);

	movss	xmm0, DWORD PTR _sz$116729[esp+20]
	fstp	ST(0)
	movss	DWORD PTR [esi+24], xmm0
$LN29@CGameFont@2:

; 34   : 	}
; 35   : 	if (pSettings->line_exist(section,"interval"))

	mov	ecx, DWORD PTR __imp_?pSettings@@3PBVCInifile@@B
	mov	ecx, DWORD PTR [ecx]
	push	OFFSET ??_C@_08CBFCMNKF@interval?$AA@
	push	edi
	call	ebx
	test	eax, eax
	je	SHORT $LN35@CGameFont@2

; 36   : 		SetInterval(pSettings->r_fvector2(section,"interval"));

	mov	eax, DWORD PTR __imp_?pSettings@@3PBVCInifile@@B
	mov	ecx, DWORD PTR [eax]
	push	OFFSET ??_C@_08CBFCMNKF@interval?$AA@
	push	edi
	lea	edx, DWORD PTR $T368543[esp+32]
	push	edx
	call	DWORD PTR __imp_?r_fvector2@CInifile@@QBE?AU?$_vector2@M@@PBD0@Z
	push	eax
	lea	ecx, DWORD PTR [esi+36]
	call	?set@?$_vector2@M@@QAEAAU1@ABU1@@Z	; _vector2<float>::set
$LN35@CGameFont@2:
	pop	edi

; 37   : }

	mov	eax, esi
	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
??0CGameFont@@QAE@PBDI@Z ENDP				; CGameFont::CGameFont
PUBLIC	?OutNext@CGameFont@@QAAXPBDZZ			; CGameFont::OutNext
; Function compile flags: /Ogtpy
;	COMDAT ?OutNext@CGameFont@@QAAXPBDZZ
_TEXT	SEGMENT
_rs$436686 = -1044					; size = 1044
_this$ = 8						; size = 4
_fmt$ = 12						; size = 4
?OutNext@CGameFont@@QAAXPBDZZ PROC			; CGameFont::OutNext, COMDAT

; 306  : {

	sub	esp, 1044				; 00000414H

; 307  : 	MASTER_OUT( TRUE , FALSE , FALSE , TRUE , 0.0f , 0.0f , 1.0f , fmt );

	cmp	DWORD PTR ?Device@@3VCRenderDevice@@A+20, 0
	je	$LN37@OutNext
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+1044]
	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+16]
	movss	xmm0, DWORD PTR [ebx+28]
	lea	edx, DWORD PTR _fmt$[esp+1048]
	push	edx
	mov	DWORD PTR _rs$436686[esp+2088], eax
	mov	eax, DWORD PTR _fmt$[esp+1048]
	push	eax
	movss	DWORD PTR _rs$436686[esp+2080], xmm0
	movss	xmm0, DWORD PTR [ebx+32]
	mov	DWORD PTR _rs$436686[esp+2096], ecx
	lea	ecx, DWORD PTR _rs$436686[esp+1056]
	movss	DWORD PTR _rs$436686[esp+2084], xmm0
	movss	xmm0, DWORD PTR [ebx+24]
	push	1024					; 00000400H
	push	ecx
	movss	DWORD PTR _rs$436686[esp+2096], xmm0
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	cmp	eax, -1
	mov	BYTE PTR _rs$436686[esp+2071], 0
	je	SHORT $LN41@OutNext
	test	eax, eax
	je	SHORT $LN27@OutNext
	mov	eax, DWORD PTR [ebx+68]
	cmp	eax, DWORD PTR [ebx+72]
	lea	edx, DWORD PTR [ebx+64]
	je	SHORT $LN28@OutNext
	test	eax, eax
	je	SHORT $LN33@OutNext
	push	esi
	push	edi
	mov	ecx, 261				; 00000105H
	lea	esi, DWORD PTR _rs$436686[esp+1056]
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
$LN33@OutNext:
	add	DWORD PTR [edx+4], 1044			; 00000414H
	jmp	SHORT $LN27@OutNext
$LN28@OutNext:
	lea	ecx, DWORD PTR _rs$436686[esp+1048]
	push	ecx
	push	edx
	call	?_M_insert_overflow@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_insert_overflow
$LN27@OutNext:
	movss	xmm0, DWORD PTR [ebx+40]
	mulss	xmm0, DWORD PTR [ebx+24]
	addss	xmm0, DWORD PTR [ebx+32]
	movss	DWORD PTR [ebx+32], xmm0
$LN41@OutNext:
	pop	ebx
$LN37@OutNext:

; 308  : };

	add	esp, 1044				; 00000414H
	ret	0
?OutNext@CGameFont@@QAAXPBDZZ ENDP			; CGameFont::OutNext
_TEXT	ENDS
PUBLIC	?Out@CGameFont@@QAAXMMPBDZZ			; CGameFont::Out
; Function compile flags: /Ogtpy
;	COMDAT ?Out@CGameFont@@QAAXMMPBDZZ
_TEXT	SEGMENT
_rs$436827 = -1044					; size = 1044
_this$ = 8						; size = 4
__x$ = 12						; size = 4
__y$ = 16						; size = 4
_fmt$ = 20						; size = 4
?Out@CGameFont@@QAAXMMPBDZZ PROC			; CGameFont::Out, COMDAT

; 301  : {

	sub	esp, 1044				; 00000414H

; 302  : 	MASTER_OUT( TRUE , TRUE , FALSE , FALSE , _x , _y , 0.0f , fmt );

	cmp	DWORD PTR ?Device@@3VCRenderDevice@@A+20, 0
	je	$LN27@Out
	movss	xmm0, DWORD PTR __x$[esp+1040]
	push	esi
	mov	esi, DWORD PTR _this$[esp+1044]
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR _fmt$[esp+1048]
	push	edx
	mov	DWORD PTR _rs$436827[esp+2088], eax
	mov	eax, DWORD PTR _fmt$[esp+1048]
	push	eax
	movss	DWORD PTR _rs$436827[esp+2080], xmm0
	movss	xmm0, DWORD PTR __y$[esp+1052]
	mov	DWORD PTR _rs$436827[esp+2096], ecx
	lea	ecx, DWORD PTR _rs$436827[esp+1056]
	movss	DWORD PTR _rs$436827[esp+2084], xmm0
	movss	xmm0, DWORD PTR [esi+24]
	push	1024					; 00000400H
	push	ecx
	movss	DWORD PTR _rs$436827[esp+2096], xmm0
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	cmp	eax, -1
	mov	BYTE PTR _rs$436827[esp+2071], 0
	je	SHORT $LN41@Out
	test	eax, eax
	je	SHORT $LN41@Out
	mov	eax, DWORD PTR [esi+68]
	cmp	eax, DWORD PTR [esi+72]
	lea	edx, DWORD PTR [esi+64]
	je	SHORT $LN28@Out
	test	eax, eax
	je	SHORT $LN33@Out
	push	edi
	mov	ecx, 261				; 00000105H
	lea	esi, DWORD PTR _rs$436827[esp+1052]
	mov	edi, eax
	rep movsd
	pop	edi
$LN33@Out:
	add	DWORD PTR [edx+4], 1044			; 00000414H
	pop	esi

; 303  : };

	add	esp, 1044				; 00000414H
	ret	0

; 302  : 	MASTER_OUT( TRUE , TRUE , FALSE , FALSE , _x , _y , 0.0f , fmt );

$LN28@Out:
	lea	ecx, DWORD PTR _rs$436827[esp+1048]
	push	ecx
	push	edx
	call	?_M_insert_overflow@?$_Impl_vector@UString@CGameFont@@V?$xalloc@UString@CGameFont@@@@@priv@stlp_std@@AAEXPAUString@CGameFont@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CGameFont::String,xalloc<CGameFont::String> >::_M_insert_overflow
$LN41@Out:
	pop	esi
$LN27@Out:

; 303  : };

	add	esp, 1044				; 00000414H
	ret	0
?Out@CGameFont@@QAAXMMPBDZZ ENDP			; CGameFont::Out
_TEXT	ENDS
PUBLIC	?OutI@CGameFont@@QAAXMMPBDZZ			; CGameFont::OutI
; Function compile flags: /Ogtpy
;	COMDAT ?OutI@CGameFont@@QAAXMMPBDZZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
__x$ = 12						; size = 4
__y$ = 16						; size = 4
_fmt$ = 20						; size = 4
?OutI@CGameFont@@QAAXMMPBDZZ PROC			; CGameFont::OutI, COMDAT

; 297  : 	MASTER_OUT( FALSE , TRUE , TRUE , FALSE , _x  , _y , 0.0f , fmt );

	mov	ecx, DWORD PTR _fmt$[esp-4]
	fldz
	lea	eax, DWORD PTR _fmt$[esp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+4]
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR __y$[esp+16]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __x$[esp+16]
	fstp	DWORD PTR [esp]
	push	0
	push	1
	push	1
	push	0
	call	?MasterOut@CGameFont@@QAEXHHHHMMMPBDPAD@Z ; CGameFont::MasterOut

; 298  : };

	ret	0
?OutI@CGameFont@@QAAXMMPBDZZ ENDP			; CGameFont::OutI
END
